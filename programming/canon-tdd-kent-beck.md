# ESSENTIALS - Canon Test-Driven Development - Kent Beck | Craft 2025
https://youtu.be/90VBvjYedWI?si=mmkdMq4_XFAmYZJW  
켄트벡의 tdd강연 스크립트를 번역한 내용입니다. gemini 2.5 pro를 이용했습니다.

---
## tdd란 무엇인가?

[사회자]
어제와 같이 보라색 스테이지가 거의 꽉 찼네요. 다음 연사는 프로그래머이자, 아티스트, 음악가, 그리고 포커 플레이어입니다. 그의 커리어 미션은 세상의 '긱(geek)'들이 안전하다고 느끼게 만드는 것입니다. 오늘 "캐논(정통) 테스트 주도 개발"이라는 주제로 강연해 주실 텐데요. 켄트 벡(Kent Beck) 님을 뜨거운 박수로 맞아주시기 바랍니다.
[박수]

[켄트 벡]
좋은 아침입니다. 아침 맞죠? 좋아요. 제 영혼은 어차피 대서양 어딘가에 있긴 하지만요. 그래서, 음, 여러분 모두를 잠시나마 만나게 되어 정말 반갑습니다. 이건 좀 벗을게요. 아, 너무 이르네요. 자, 됐습니다.

음, 어제 키노트에서는 큰 아이디어에 대해 이야기했는데요. 오늘은 작고, 구체적이며, 긱(geek)스러운 아이디어에 대해 이야기하려고 합니다. 저는 지난 한 달 동안 미친 듯이 프로그래밍을 해왔습니다. 제 프로그래밍 지니(genie)와 함께 정말 즐거운 시간을 보내고 있어요. 지니 아시죠, 소원을 들어주지만 당신이 생각하는 방식대로는 아니라는 거요. 그렇게 저는 지니와 함께 프로그래밍하고 있습니다. 테스트 주도 개발을 다시 적용하고 있고요. 아, 정말 즐거운 시간을 보내고 있어서, 이때가 바로 제가 테스트 주도 개발로 의도했던 바를 다시 한번 되풀이하기에 좋은 시기인 것 같았습니다.

요즘 젊은이들은, 제가 어렸을 때는 이런 형용사가 없었는데, '캐논(canon)'이라는 단어를 '오리지널'이라는 의미로 사용하더군요. 그래서 '캐논 반지의 제왕'은 톨킨이 쓴 그대로의 반지의 제왕을 의미합니다. 모든 팬픽이나, 버즈 라이트이어와 아라곤이 만나는 식의 모든 크로스오버 같은 것 말고요. 그런 건 하나도 없는, 원작 그대로를 '캐논'이라고 합니다.

그런데 제가 왜 이 이야기를 하고 있을까요? 이건 저 스스로에게도 많이 던졌던 질문입니다. 왜 나는 아직도 이 이야기를 해야만 하는가? 그 이유는 제가 항상 테스트 주도 개발에 대한 비판을 듣는데, 그게 사실 테스트 주도 개발에 대한 비판이 아니기 때문입니다. 그래서 생각했죠. "알았어, 알았어." 제 뉴스레터에도 이것에 대한 에세이 시리즈를 썼습니다. TDD란 무엇인가? 그래서 저는 결심했습니다. 좋아, 원점으로 돌아가서 "테스트 주도 개발이란 무엇인가?"를 말하겠다고요.

오늘 제 목표는 여러분에게 어떻게 프로그래밍해야 하는지를 알려주는 것이 아닙니다. 전혀요. 그리고 그건 어떤 경우에도 테스트 주도 개발의 목표가 아닙니다. 제 목표는 비판을 위한 명확한 대상을 제시하는 것입니다. 사람들이 이렇게 말하죠. "아, 저는 TDD가 싫어요. 코드를 작성하기 전에 테스트를 잔뜩 작성하고 싶지 않거든요." 그러면 저는 생각합니다. '아니, 아니, 그게 아닌데.' 또 다른 사람들은 말합니다. "오, 저는 TDD가 싫어요. 코드를 잔뜩 쓰고 나서 테스트를 또 잔뜩 써야 하잖아요." 그러면 저는 생각합니다. '아니, 아니, 그것도 아닌데.' 그건 그런 작업 흐름이 아닙니다. 저는 그 작업 흐름이 완벽하게 명확하다고 생각했는데, 명백히 아니었나 봅니다. 그래서, 한 번 더 말하려고 합니다. 그리고 이건 이번이 정말 마지막일 거라는 협박이기도 합니다. 어떻게 될지는 두고 보죠.

자, 이것이 바로 캐논 TDD입니다. 여러분이 이렇게 프로그래밍해야 한다는 것이 아닙니다. 이것은 하나의 '대상'입니다. 만약 여러분이 무언가를 비판하고 싶다면, 바로 이것을 비판하세요. 그러면 우리는 거기서부터 변형에 대해 이야기할 수 있습니다.

좋습니다. 음, 질문이 있으시다면, 저는 우리의 스폰서인 Slido를 존중하고 싶습니다. 그들이 없었다면 제 영혼은 여전히 캘리포니아에 있었을 테고 저는 여기에 비행기 타고 올 수 없었을 겁니다. 하지만 동시에, 질문이 있으시면 지금 바로 저를 방해해 주세요. 여러분이 질문을 40분 동안 속으로 끙끙 앓으며 제 말을 듣지 않는 것보다는, 그 순간에 바로 여러분의 질문에 답하는 것이 낫습니다. 그러니 언제든 저를 멈추셔도 됩니다. 제가 질문을 반복해서 말하고 계속 진행하겠습니다. 만약 즉각적인 질문이 아니라면, Slido에 접속해서 질문을 올려주세요.

자, 지금 정기적으로 TDD를 사용하고 계신 분이 얼마나 되나요? 오케이. 오케이. 좋습니다. 만약 여러분이 다른 분들을 설득해 주신다면, 우리는 여기서 끝내도 되겠네요. 아뇨, 농담입니다. 제발 그러지 마세요. 알겠습니다.

그리고 전형적인 켄트 스타일로, 저는 모든 슬라이드를 손으로 쓸 겁니다. 오, 무슨 색으로 할까요? 세상에. 좋습니다. 우리는 새로운 프로그래밍 작업 흐름을 처음부터 도출해 볼 겁니다. 우리는 프로그래밍에 대해 아무것도 모르는 척하고, 첫 번째 원칙부터 생각해 볼 것입니다. 어떤 순서로 어떤 결정을 내려야 할까요?

가장 먼저 생각해야 할 것은 이 과정의 끝에 우리가 무엇을 얻고 싶어 하는가입니다. 우리는 기능들을 구현하는 코드 뭉치를 얻고 싶어 합니다. 하지만 우리는 이 코드를 계속해서 변경하고 싶기 때문에, 테스트 뭉치도 함께 얻고 싶습니다.

테스트의 목표는 두 가지입니다. 하나는 코드가 우리가 생각하는 대로 실제로 동작한다는 '자신감'입니다. 이는 우리 개인을 위한 자신감이고, 동료들을 위한 자신감입니다. "오, 내가 코드를 좀 바꿨어. 오, 안 돼. 또 그러지 마." 아니요, 만약 제게 테스트가 있다면, 여러분은 제가 한 일에 대해 더 많은 자신감을 가질 수 있습니다. 그리고 우리 사용자를 위한 자신감이기도 합니다. 얼마 전에 BMW 차에 탔는데, "무선 업데이트(over-the-air upload) 가능"이라고 뜨더군요. 그러자 차 주인이 '취소'를 눌렀습니다. "저는 어떤 업그레이드도 원치 않아요." 이건 슬픈 일입니다. 사람들이 우리가 무언가를 망가뜨리지 않을 것이라고 믿지 않는다는 것, 우리 직업에 대한 논평이죠. 그래서 크게 보면, 우리는 자신감을 갖고 싶고, 그 자신감을 다른 사람들과 나누고 싶습니다.

이것이 우리가 도달하고 싶은 지점입니다. 그럼 어떻게 거기에 도달할까요? 한 가지 우리가 사용할 수 있는 순서는 이렇습니다. 코드를 좀 작성하고, 코드를 더 작성하고, 코드를 더 작성합니다. 그런 다음 테스트를 작성하고, 또 다른 테스트를, 그리고 또 다른 테스트를 작성합니다. 이것은 매우 합리적인 순서입니다.

사람들은 제게 이렇게 말합니다. "좋아요, 하지만 TDD는 제 작업 흐름에 맞지 않아요. 제 작업 흐름은 API 문서를 먼저 작성하고, 그 다음에 모듈이 될 파일들을 정하는 거예요." 우리가 아직도 소스 코드를 파일에 넣는다는 건 좀 슬픈 일이지만, 그건 다른 날의 주제고요.

"그래서 저는 API 문서를 쓰고, 모듈이 될 것들을 정하고, 어떤 함수가 어떤 모듈에 들어갈지 정한 다음, 각 함수의 본문을 채워 넣습니다. 그리고 나면 끝이죠." 저는 생각합니다. '음, 끔찍한 작업 흐름처럼 들리지는 않네요.' 하지만 만약 여기서 실수를 하거나, 코드의 첫 부분에 영향을 미치는 무언가를 발견하면 어떻게 될까요? 이런. 이제 두 가지를 바꿔야 합니다. 그리고 만약 여기서 실수를 발견해서 이전에 썼던 코드를 바꿔야 하고, 그로 인해 그 이전에 썼던 코드를 또 바꿔야 한다면요? 바로 '결합(coupling)' 때문이죠. 좋습니다, 이건 잠재적으로 비용이 많이 드는 시나리오입니다.

그렇다면, 우리가 여기까지 오기 전에 피드백을 좀 받는다면 어떨까요? 거기에 도달하기 전에 피드백을 원한다면요? 좋습니다. 여기 우리가 따를 수 있는 또 다른 순서가 있습니다. 저는 코드를 좀 작성하고, 그런 다음 테스트를 작성할 수 있습니다. 이제 저는 첫 번째 코드가 작동하는지에 대한 피드백을 얻습니다. 그리고 코드를 좀 더 작성하고, 테스트를 작성합니다. 그리고 두 테스트 세트를 모두 실행해서 모든 것이 작동하는지 확인합니다. 그리고 코드를 좀 더 작성하고, 또 다른 테스트를 작성합니다.

좋습니다. 이것은 나중에 배운 것이 이전 작업을 무효화하는 이런 종류의 시나리오를 방지하거나 줄여줍니다. 하지만 이것은 의존성을 도입합니다. 어떤 색으로 할까요? 이걸로 하죠. 이 순서는 제가 이 코드를 작성할 때, 이미 실행될 수 있는 무언가를 작성해야 한다는 것을 의미합니다. 그래서 제 친구들의 순서, 즉 API 문서를 쓰고, 모든 파일을 배치하고, 모든 함수를 배치하는 방식은, 그 모든 것을 끝내기 전까지는 실행할 수 없습니다. 컴파일도, 실행도 할 수 없죠.

그래서 여기에는 기술이 필요합니다. 제가 작성할 이 모든 코드를 분해해야 합니다. 이 종류의 작업 흐름에 있을 때 사용하는 덩어리와는 다른 덩어리로 나눠야 합니다. 컴파일하고 실행할 수 있는 코드를 여기에 작성해야 합니다. 여러분의 프로그래밍 언어와 환경에 따라 이것이 얼마나 쉽거나 어려운지는 다르겠지만, 테스트를 나누어 조금씩 하는 것의 함의입니다.

그런 다음, 저는 바로 그 부분만을 위한 테스트를 작성하는 방법을 알아내야 합니다. 그리고 두 번째 코드 세그먼트를 작성하는데, 이것 또한 실행 가능해야 그에 대한 테스트를 실행할 수 있습니다. 그런 다음 세 번째 코드 부분을 작성해서 그것들을 모두 함께 테스트할 수 있어야 합니다.

그래서 이 순서, 아래쪽 순서에는 기술이 필요합니다. 위에서는 필요하지 않은 기술이죠. 위에서는 코드 라인들을, 예를 들어 천 줄의 코드를 만들 것이라면, 제가 원하는 어떤 순서로든 작성할 수 있습니다. 처음부터 시작할 수도, 끝에서 시작할 수도, 중간 어딘가에서 시작할 수도 있습니다. 제가 그 코드 라인들을 작성하는 순서에 대해 걱정할 필요가 없습니다.

만약 제가 아래의 이 순서, 즉 코드와 테스트, 코드와 테스트를 번갈아 하는 순서를 따르려면, 저는 아직 다 작성하지 않은 상태에서도 실행할 수 있는 방식으로 제가 작성하는 라인들의 순서를 정하는 기술을 배워야 합니다. 위에서는 모든 것을 다 써야 실행할 수 있습니다. 아래에서는, 살라미를 어떻게 얇게 썰고 어떤 순서로 그 조각들을 먹어야 다 완성되기 전에 실행할 수 있을지를 알아내야 합니다. 그리고 거기에는 분명히 기술이 있습니다. 아직 아무도 그 기술에 대해 깊이 파고든 사람은 없는 것 같습니다. 일반적인 패턴은 무엇인지, 교육학은 어떤지, 어떻게 다른 사람에게 그것을 가르칠 수 있는지. 아무도요. 그래서 만약 여러분이 프로젝트를 찾고 있다면, 코드 라인들을 특정 순서로 작성한다는 것이 무엇을 의미하는지 정말 깊이 파고드는 것 말입니다. 만약 천 개의 라인이 있다면, 천 팩토리얼 개의 순열이 있습니다. 그 순열 중 일부는 의미가 있고 다른 일부는 의미가 없습니다. 만약 제가 이렇게 조각별로 테스트할 수 있다는 목표를 달성하고 싶다면요.

지금까지 질문 있나요? 좋습니다.

또 다른 함의.
[청중] 켄트. 네. 소스 코드에 대한 질문이 있습니다. 죄송합니다. 소스 코드를 파일에 넣는 것에 대한 언급에 대해, 합리적인 대안은 무엇인가요?

[켄트 벡]
합리적인 대안이 무엇이냐고요? 소스 코드를 파일에 넣는 것에 대한 언급에 대해, 합리적인 대안이 무엇인가요? 오. 오. 오. 소스 코드를 파일에 넣지 않는다면, 객체(object)에 넣습니다. 40년 동안 해왔던 방식이고 정말 잘 작동하지만, 아무도 그 답을 듣고 싶어 하지 않죠. 스몰토크(Smalltalk) 말입니다. 감사합니다. 하지만 그 대화는 나중에 하도록 하죠. 알겠습니다.

자 이제 우리는 질문에 도달합니다. 우리는 코드 다음에 테스트를 하는 순서를 가지고 있습니다. 여기서 코드 부분은 세 가지의 뚜렷한 질문들로 더 세분화됩니다.

제가 추가하고 싶은 어떤 기능이 있습니다. 시스템의 동작을 바꾸고 싶습니다. 저는 세 가지 종류의 결정을 내려야 합니다.
저는 API가 무엇인지 결정해야 합니다. 이 기능을 어떻게 호출할 것인가?
입력/출력 동작은 무엇인가? 즉, 제가 작성하려는 로직에 어떤 입력이 들어가고, 그 로직에서 어떤 출력을 기대하는가?
그리고 구현 자체입니다.

코딩을 하는 동안 이 세 가지를 모두 생각해야 합니다. 이 세 가지를 모두 끝내야 테스트로 넘어갈 수 있습니다. 저는 생각합니다. '좋아, 여기 가장 작은 구현 단위가 있어. 시스템에 이 작은 변경을 할 거야.' 저는 그것을 어떻게 호출할지, 입력과 출력이 무엇이 될지(정의역과 치역), 그리고 구현이 어떻게 구조화될지를 결정해야 합니다. 그리고 저는 이 세 가지 결정을 모두 내려야 테스트를 작성할 수 있습니다.

이제, 제 근본적인 원칙 중 하나는 복잡성을 나누는 것입니다. 저는 복잡성을 세분화하고 싶습니다. 큰 복잡한 문제가 있다면, 저는 그것을 상호작용하지 않는 두 개 이상의 더 간단한 문제로 나눕니다. 사람들은 그 '상호작용하지 않는' 부분을 잊어버리곤 하지만, 그건 꽤 중요합니다. 그렇지 않으면 이 문제와 저 문제, 그리고 그 둘의 상호작용을 해결해야 하는데, 이건 그냥 한 번에 큰 덩어리로 해결하는 것보다 더 어렵습니다.

그래서 제가 이 순서, 즉 코드 다음에 테스트를 하는, 완벽하게 말이 되는 순서를 따를 때, 저는 제가 한 일에 대한 피드백을 얻기 전에 이 세 가지 결정을 모두 내려야 합니다.

80년대 후반쯤이었을까요, 제가 첫 번째 테스팅 프레임워크를 썼을 때 말입니다. JUnit은 많은 사람들이 사용해 본 자바용 프레임워크죠. 저는 그 전에 스몰토크로 테스팅 프레임워크를 썼습니다. 저는 제 코드와 함께 많은 테스트를 작성하고 있었고, 이런 바보 같은 아이디어가 떠올랐습니다. 바보 같은 아이디어 맞죠? 그런데 말이죠, 바보 같은 아이디어를 시도해 보세요. 만약 그게 맞는 것으로 판명되면, 정말 가치가 있을 겁니다. 첫째로 그렇고, 둘째로, 당신은 경쟁자가 없을 겁니다. 왜냐하면 다른 누구도 그 바보 같은 아이디어를 시도할 만큼 멍청하지 않으니까요. 이 원칙은 우리 직업처럼 지금 빠르게 변하는 상황에서 특히 중요합니다.

그래서 만약 여러분이 "코딩 지니를 써봐야 할까?"라고 생각한다면, 물론입니다. 그리고 생각할 수 있는 모든 미친 실험을 해보세요. 왜냐하면 만약 그게 효과가 있다면, 엄청나게 강력할 것이기 때문입니다.

좋습니다. 그래서 저는 이 테스팅 프레임워크를 가지고 있었는데, 이게 테스트를 더 싸고 간단하게 만들어 줬습니다. 테스트를 잔뜩 쓰고, 한 번에 모두 실행할 수 있었죠. 정말 빨랐습니다. 그리고 저는 이 아이디어를 생각했습니다. "만약 순서를 바꾸면 어떨까?" 모두가 코딩하고 나서 테스트합니다. 그게 말이 되죠. 하지만 만약 제가 순서를 바꾼다면요? 저는 그 생각을 했을 때 소리 내어 웃었던 것을 기억합니다. 그건 정말 바보 같은 아이디어 중 하나였습니다. 말이 안 되잖아요. 만약 제가 테스트를 먼저 쓰면, 실패할 겁니다. 그리고 저는 테스트가 통과하기를 원하잖아요, 그렇죠? 그러니 왜 실패가 보장된 테스트를 먼저 쓰겠어요? 코드를 쓰고 나서 테스트를 쓰면, 테스트가 통과할 수도 있고 아닐 수도 있습니다. 하지만 통과하면, 와우, 제가 이긴 거죠. 실패하면, 오, 그럼 슬프고요. 그래서 저는 그걸 바꿔서 테스트를 먼저 쓰기로 했습니다. 실패가 보장되죠. 오, 매번 울어야겠네요.

좋습니다. 뭐, 한번 해보죠. 제 첫 번째 예제는 그냥 스택이었습니다. 스택을 만들면, 비어있죠. 푸시하고 팝합니다. 제가 푸시한 것과 같은 것을 팝합니다. 두 개를 푸시하고, 두 개를 팝합니다. 올바른 순서로 돌아옵니다. 빈 스택을 팝하려고 시도합니다. 이제 끝났나요? 네. 네. 실패할 만한 다른 테스트를 더 이상 상상할 수 없었습니다. 그리고 그 순간은 저에게 정말 마법 같았습니다. 왜냐하면 저는 불안한 사람이거든요. 이건 마치 프로그래머를 위한 자낙스(신경안정제) 같았습니다. 불안을 완전히 잠재워주죠. "뭐? 뭐가 더 깨질 수 있지?" 한밤중에 깨어나서 '오, 혹시...' 생각하면 그냥 버튼을 누르고 테스트를 돌리면 다시 잠들 수 있습니다. 제가 그렇게 한다는 말은 아닙니다. 그렇게 하지 않는다는 말도 아니고요.

좋습니다. 좋습니다. 여기 정말 멋진 점 중 하나가 있습니다. 만약 제가 테스트를 먼저 쓴다면, 저는 이 세 가지 종류의 결정을 내리는 순서를 선택할 수 있고, 각 단계마다 피드백을 받을 수 있습니다.

그래서 제가 테스트를 쓰기 위해 테스트를 작성한다면, 저는 결정해야 합니다. 사실 그럴 필요는 없지만요. 그건 잠시 후에 이야기하겠습니다. 저는 API가 무엇인지 결정해야 합니다. "오, 이 스택 객체가 있구나. 푸시와 팝 연산이 있네." 좋습니다. 그리고 그것이 테스트에 표현됩니다. 하지만 저는 그것이 어떻게 구현되었는지는 신경 쓰지 않습니다. 이것이 연결 리스트로 구현되었는지, 배열로 구현되었는지, 아니면 어떤 확률적 구조로 구현되었는지. 모릅니다. 신경 안 씁니다.

그런 다음 입력/출력 동작을 결정할 수 있습니다. "좋아. 이 경우, 1을 푸시하고 1을 팝하면 같은 것이 돌아온다." 이것이 입력/출력 동작입니다. 그리고 나서 구현을 시도할 수 있습니다. "좋아, 이걸 연결 리스트로 만들자. 어쩌고저쩌고..." 그렇게 진행합니다. 또는 스택이나 배열로 하고요.

하지만 저는 그 순서대로 할 필요가 없습니다. 저는 입력/출력 결정부터 시작할 수 있습니다. 이것은 제임스 뉴커크(James Newkirk)가 저에게 가르쳐준 'assert first'라는 기법인데, 테스트의 마지막 줄부터 시작하는 겁니다. "assert equals actual expected"라고 말이죠. "좋아, 그럼 expected(기대값)는 뭐지? 5를 푸시했다면 5를 얻을 것으로 기대하지." 그래서 기대값은 5입니다. "actual(실제값)은 뭐지?" actual = stack.pop()이라는 임시 변수입니다. "좋아, 하지만 그게 일어나기 전에 stack.push(5)를 해야 해." 그리고 그게 일어나기 전에 stack = Stack.new()를 해야 합니다. 그래서 저는 같은 결과에 도달하는 결정들을 내릴 수 있지만, 만약 제가 테스트 안에서 작업하고 있다면 완전히 다른 순서로 그것들을 내릴 수 있습니다. 그래서 저는 입력/출력 동작으로 시작해서, 그 경우엔 API로 갑니다. 이제 구현을 해야 합니다.

여러분은 꽤 수준 높은 청중처럼 보이네요. 그래서 저는 좀 멋진 얘기를 깊이 파고들어 보겠습니다. 네, 제가 좀 아부하는 것 같지만, 괜찮아요. 여러분은 정말 경험 많은 청중처럼 보입니다.

여러분은 실제로 이 결정들을 다른 순서로 내릴 수 있습니다. 우리는 구현부터 시작할 수 있습니다. 이것은 제 친구 키스 브레이스웨이트(Keith Braithwaite)가 "TDD as if you meant it(TDD, 진심인 것처럼)"이라고 부르는 기법입니다. 저는 제 테스트 안에서, 나중에 다른 곳에서 사용할 것으로 기대하는 푸시와 팝의 로직을 구현할 겁니다. 자, 여기 알고리즘이 있습니다. 배열을 만들고, 헤드를 가리키는 포인터를 가집니다. 푸시는 배열에 무언가를 추가하고 포인터를 전진시키는 것입니다. 팝은 무언가를 빼내고 포인터를 감소시키는 것입니다. 이제 저는 "expected equals actual"이라고 말할 수 있고, 그렇게 진행합니다.

그래서 저는 구현을 할 수 있습니다. 제가 그것을 어떻게 호출하고 싶은지 모른다고 해봅시다. 이것이 어딘가의 함수인지, 어딘가의 객체인지, 아니면 자체 모듈인지 모릅니다. 그런 결정들은 아직 내리고 싶지 않습니다. 저는 여전히 구현 작업을 할 수 있고, 그런 다음 입력/출력 동작을 알아내고, 그 후에 테스트 안에 임시로 살고 있던 이 구현을 다른 어딘가에 있는 최종 안식처로 추출해낼 수 있습니다.

코드와 테스트의 순서를 바꿈으로써, 저는 제 작업 흐름을 제가 원하는 어떤 순서로든 결정을 내릴 수 있도록 자유롭게 만들었습니다. 그건 꽤 멋진 일이죠.

[청중] 질문 있습니다. 만약 배열을 사용한다면, 당신은 이미 배열의 크기에 대한 암묵적인 가정을 하고 있는 것입니다.

[켄트 벡] 네. 네. 물론입니다.

[청중] 그 말은 나중에 오버플로우의 위험에 처할 수 있다는 뜻이죠.

[켄트 벡] 네. 그러니 나중에 그것에 대한 테스트를 꼭 작성해야 합니다. 나중에 그 테스트를 작성하지 않으면 안 됩니다. 이건 또 다른 논쟁거리죠. "오, TDD를 쓰면 현재 테스트만 만족시키고 코드가 일반적인 경우에는 제대로 작동하지 않을 거야." 글쎄요, 그렇게 하지 마세요.

네, 저는 그 감정적인 반응의 강도를 이해하지 못하겠습니다. 음, 누군가 저에게 그걸 설명해 줄 수 있다면 정말 감사하겠습니다. 사람들이 제게 와서 깊이 부끄러워하며 말합니다. "음, 저는 TDD를 하지 않아요." 제 얼굴 어디에 제가 신경 쓰는 것처럼 보이는 부분이 있나요? 그리고는 화를 내는 사람들도 있습니다. "나한테 이걸 강요할 수 없어." 제 얼굴 어디에 제가 신경 쓰는 것처럼 보이는 부분이 있나요? 어쨌든, 누군가 그걸 설명해 줄 수 있겠죠. 제가 하지는 않을 겁니다. 알겠습니다.

자, 한 가지 더, 우리가 캐논 TDD에 도달하기 전에요. 약속하건대, 도달할 겁니다. 하지만 그 전에 잠시 생각해보고 싶습니다. 우리에게는 이 대안이 있습니다. 우리의 작업 흐름을 코드 다음에 테스트로 할 수도 있고, 테스트 다음에 코드로 할 수도 있습니다. 그것의 경제학은 어떨까요? 왜 우리는 테스트를 작성과 번갈아 가며 하고 싶어 할까요? 우리는 '코드, 코드 -> 테스트, 테스트'를 할 수도 있고, '코드, 테스트, 코드, 테스트, 코드, 테스트'를 할 수도 있었습니다. 그것의 경제학은 무엇일까요? 왜 우리는 코드 작성 순서를 제약하는 추가적인 부담을 지고 싶어 할까요?

자, 이것이 제가 그것에 대해 조금 생각해 본 것입니다. 여기 시간에 따른 가치와 비용이 있습니다. 그리고 바로 여기가, 이걸 써야겠네요. 여기가 코드입니다.

만약 우리가 코드를 작성하기 훨씬 전에 테스트를 작성한다면, 그것들은 가치가 거의 없습니다. 왜냐하면 우리는 수많은 가정을 하고 있기 때문입니다. 우리는 테스트를 다시 작성해야 할 겁니다. 모든 것이 바뀔 수도 있는데도 우리는 그것들을 유지해야 합니다. 우리는 이걸 구현하지 않을 수도 있습니다. 그래서 우리가 포기하는 작업이 더 많아집니다.

구현 시간에 가까워질수록, 오, 멍청한 그림 프로그램. 이건 직선이 아니네요. 구현 시간에 가까워질수록, 테스트의 가치는 더 높아집니다. 왜냐하면 그것들은 우리가 내린 API, 입력/출력, 그리고 구현 결정들이 올바른지에 대한 피드백을 주기 때문입니다. 그래서 코드를 작성할 즈음에 테스트의 가치는 최고조에 달합니다. 하지만 피드백을 기다리는 시간이 길어질수록, 테스트의 가치는 떨어집니다. 아시다시피, 코드를 프로덕션에 배포한 후에는 테스트는 그다지 가치가 없습니다.

비용은 비슷한 곡선을 그리지만, 이것은 음수입니다. 만약 우리가 테스트를 아주 일찍 작성한다면, 비용은 매우 높습니다. 왜냐하면 이 모든 재작업이 있을 것이기 때문입니다. 그리고 가까워질수록 비용은 낮아집니다. 그래서 코드를 작성할 즈음에 비용은 최소가 됩니다.

만약 우리가 코드를 작성할 즈음에 테스트를 작성하지 않는다면, 코드는 기본적으로 테스트 가능하지 않을 것입니다. 코드를 테스트 가능하게 만드는 습관을 가질 수는 있지만, 시간이 지날수록 점점 더 비싸질 겁니다.

그래서 만약 우리가 이 두 곡선을 합산하면, 이 곡선에서 저 곡선을 빼면, 명백히 코드를 작성할 즈음이 테스트를 작성하기에 가장 가치 있고 가장 비용이 적게 드는 시간입니다. 이것이 우리가 이 순서, 즉 '코드와 테스트, 코드와 테스트'를 선택하는 이유입니다. 단, 어떤 순서로 그것들을 할 것인지, 어떤 순서로 순서를 시작할 것인지에 대한 질문이 남습니다.

좋습니다, 이제 우리는 캐논 TDD를 할 준비가 되었습니다. 이것이 우리가 이 모든 결정을 내리는 이유입니다.

이것은 2단계 프로세스입니다.
1단계: 시나리오.
즉, 우리는 어떤 기능을 구현하고 있는데, '음, 오버플로우, 언더플로우, 요소 하나, 요소 두 개를 처리해야 해'라고 생각합니다. 그 외에 지금 당장 생각나는 다른 것은 없습니다.
음, 타입(types)은 테스트의 일부가 될 겁니다.
시나리오는 로직을 통과하는 경로들입니다. 예를 들어, 이자율을 계산하는 두 가지 다른 방법이 있을 수 있습니다. 우리는 이자율을 계산하는 각 방법에 대해 적어도 하나의 테스트가 필요하다는 것을 압니다.

그래서 저는 항상 목록부터 시작합니다. 그리고 이것은 아마도 저와 불안, 그리고 ADD(주의력 결핍 장애)와 관련이 있을 겁니다. 저는 '주의력 결핍 장애'라는 용어를 좋아하지 않습니다. 왜냐하면 저는 주의력이 결핍된 게 아니거든요. 저는 주의력이 많습니다. 그냥 정말 쉽게 지루해질 뿐이죠. 그래서 저는 그것을 '지루함 민감성(boredom sensitivity)'이라고 부르는 것을 선호합니다. 마치 땅콩 알레르기 같은데, 지루함에 대한 거죠. 그래서 저는 제 주의력을 집중시킬 방법이 필요합니다. 제 주의력은 매우 많지만, 변덕스럽죠. TDD는 제가 그렇게 하도록 돕고, 시나리오도 그렇게 하도록 돕습니다.

시나리오가 저를 돕는 두 번째 것은, "내가 끝났다는 것을 어떻게 알까?"입니다. 왜냐하면 저는 그 불안한 사람이기 때문이죠. 저는 항상 한 가지 더 생각할 수 있습니다. 만약 제가 시나리오 목록을 가지고 있고 그것들을 모두 지웠다면, 제 평생에 걸쳐 저는 지워진 것들이 있는 많은 목록들을 가지고 있었고, 그것은 제 자신의 불안을 관리하는 방법입니다. 그래서 저는 시나리오 목록부터 시작합니다. 여기 제가 오늘 알고 있는 로직을 통과하는 경로들이 있습니다.

그런 다음 2단계 A는 테스트를 작성하는 것입니다.
즉, 저는 프로젝트에 진전이 있다면 녹색이 되고, 제가 진전이 있다고 생각하든 아니든 프로젝트에 진전이 없다면 빨간색이 될 일련의 문장들을 작성할 것입니다. 이것이 바로 테스트 주도(test-driven) 부분입니다.

2B는 그것을 통과시키는 것입니다.
즉, 일단 빨간색 테스트가 생기면, 저는 그것을 녹색으로 만드는 것 외에는 아무것도 신경 쓰지 않습니다. 어떻게 하면 가능한 한 빨리 녹색으로 만들 수 있을까? 그리고 여기서 저는 제 불안을 제게 유리하게 사용합니다. 저는 백만 가지 다른 시나리오를 상상할 수 있고, 이것을 어떻게 구현할지, 저것을 어떻게 구현할지 생각하며 다른 곳으로 빠져들 수 있습니다. 제 가장 좋아하는 회피 행동은 손톱을 다듬는 것입니다. 왜냐하면 저는 클래식 기타리스트거든요. 그래서 제가 하고 있는 코딩에 대해 정말 걱정이 되면, 갑자기 "오, 안 돼"라고 생각하고는 화장실로 가서 한동안 아주 조심스럽게 손톱을 다듬습니다. 그건 사실 어떤 코드도 완성시키지 못합니다. 눈치채셨는지 모르겠지만, 그건 그냥 제 회피 행동일 뿐입니다.

그래서, 저는 테스트를 가지고 있습니다. 빨간색입니다. 저는 그것을 녹색으로 만들 겁니다. 이제, 저는 제가 작성할 것으로 기대하는 코드로 녹색으로 만들고 싶지만, 꼭 그럴 필요는 없을 수도 있습니다.
(기차 소리)
오, 이 컨퍼런스는 정말 훌륭하고, 장소도 훌륭한데, 제 발표 중간에 바로 기차를 배치했다는 사실은 정말 친절하네요. 정말 감사합니다.

그래서, 저는 제가 쓰고 싶은 코드를 쓰고 싶지만, 어쩌면 그게 저에게는 너무 복잡할 수 있습니다. 그래서 저는 녹색에 도달하기 위해 필요하다면 '통과시키기' 부분에서 온갖 죄를 저지를 겁니다. 왜냐하면 저는 항상 C 단계, 즉 '일반화' 단계로 올 것이라는 것을 알기 때문입니다. 이 단계에서 저는, 테스트 주도 개발은 특정 시나리오에서 주도되지만, 우리는 일반적인 상황에서 작동하는 코드를 원합니다.

우리는 다른 모든 입력도 작동할 것이라는 것을 암시하는 테스트 또는 테스트 세트를 선택하고 싶습니다. 그래서 이 일반화 단계에서, 이제 저는 다시 녹색 상태로 돌아왔습니다. 새로운 테스트가 있고, 통과합니다. 저는 일반화하는 동안 그것을 녹색으로 유지하고 싶습니다. 그리고 저는 이것을 여러 가지 다른 방법으로 할 수 있습니다. 다시 말하지만, 만약 여러분이 석사 과정 학생이라면, 여기 훌륭한 연구 주제가 있습니다. 테스트가 통과되면 코드를 일반화할 수 있는 모든 방법은 무엇인가?

예를 들어, 저는 디자인을 일반화할 수 있습니다. 저는 "좋아, 음, 테스트를 통과시켰지만, 코드를 복사-붙여넣기(copy-pasta) 해야 했어."라고 말할 수 있습니다. 헝가리에도 코드를 복사해서 붙여넣고 편집해서 이제 결합(coupling)이 생기는 '복사-붙여넣기'가 있나요? 여기서는 그렇게 안 하시죠. 네. 믿겠습니다, 선생님. 음, 좋습니다. 그래서, 어쩌면 제가 그렇게 했을 수도 있지만, 저는 봅니다. "좋아. 이 코드와 저 코드 사이에 중복이 좀 있네. 그러니 여기서 헬퍼(helper)를 추출해서 저기서 사용하자." 이것이 이제 일반화입니다. 저는 디자인을 일반화하고 있습니다.

때로는 구현을 일반화합니다. 이것은 제가 얼마 전에 링크드인에 올렸던 것 같은데, 이 순서입니다. 저는 "100유로를 가지고 있고 5% 이자를 받으면 1년 후에 105유로가 있어야 한다"는 테스트를 가지고 있습니다. 그리고 저는 제 구현 단계, 즉 '통과시키기' 단계에서 그냥 "return 105"라고 말할 수도 있습니다. 하지만 저는 아직 끝나지 않았다는 것을 압니다. 그래서 그 105는 사실 원금 더하기 이자입니다. 그래서 저는 그냥 "return 105"라고 말하는 구현을 "return principal + interest"로 바꿉니다. 그리고 principal은 그냥 "return 100"이라고 말하고, interest는 그냥 "return 5"라고 말합니다. 그런 다음 저는 다시 돌아가서 말합니다. "오, 하지만 그 원금은 사실 초기 예금액인데, 이건 테스트에는 있었지만 이제 구현 어디에도 나타나지 않아." 이제 저는 그것을 연결할 방법을 찾아야 합니다. 그리고 이자는 이율 곱하기 원금입니다. 그리고 이율은 어디서 오는가? 이제 저는 완벽하게 일반적인 코드를 갖게 됩니다. 하지만 저는 대부분의 구현 결정을 테스트가 모두 녹색인 상태에서 내렸습니다. 이것은 불안한 사람에게는 마법과도 같습니다.

때로는 단순화할 수 있습니다. 테스트를 통과시키기 위해 무언가를 했는데, "오, 사실 이 계산을 훨씬 더 간단한 것으로 재구성할 수 있겠다"라고 말합니다. 좋습니다. 그리고 때로는 추상화합니다. 저는 말합니다. "좋아, 이걸 작동시켰어. 구체적인 클래스가 있었는데, 이제 그 클래스에 대한 인터페이스를 도입하고 싶어. 왜냐하면 곧 사용할 것이기 때문에, 또는 미래의 독자들에게 더 잘 읽힐 것이기 때문에, 또는 뭐든지 간에." 하지만 그 일반화 단계, 이것은 많은 비평가들이 놓치는 것처럼 보이는 TDD의 한 조각입니다. 제가 일반화에 얼마나 많은 시간을 쓰는지 말입니다.

저는 유튜브에서 찾을 수 있는 스크린캐스트 시리즈를 녹화했는데, 거기서 '테스트-커밋-되돌리기(test commit revert)'라는 TDD의 변형을 사용했습니다. 만약 테스트가 실패하면, 마지막 통과 이후의 모든 변경 사항이 즉시 삭제됩니다. 이건 끔찍한 아이디어인데, 정말 재미있으니 여러분도 한번 해보세요.

음, 그래서 저는 이 데이터 구조, 로프(rope) 데이터 구조를 만들었고, 마지막 절반을, 약 한 시간 정도 걸리는데, 마지막 30분을 그냥 리팩토링, 바로 이 일반화 단계에 썼습니다. 파이썬처럼 보이게 만들려고요. 파이썬으로 구현된 것 같습니다. 파이셔처럼 보이게 만들고, 다음 단계를 위해 준비되도록 깔끔하게 정리하는 거죠. 그리고 저는 그것이 놓쳐지는 부분이라고 생각합니다.

자, 거기 신사 숙녀 여러분, 그리고 그 사이의 모든 분들, 이것이 바로 캐논 TDD입니다.

여러분은 이 단계들을 따라야 할까요? 저는 "절대 아닙니다"라고 말하려던 참이었습니다. 어쩌면요. 어쩌면 여러분은 이 단계들을 따라야 할지도 모릅니다. 만약 여러분이 TDD를 비판하고 싶다면, 이것을 비판하세요. 저는 그 대화를 기꺼이 나눌 겁니다. "음, 저는 코드 작성 전에 테스트를 잔뜩 쓰는 게 싫어요"라고 말하는 사람과는 그 대화를 나눌 관심이 없습니다. 왜냐하면 그건 TDD에 대한 것이 아니기 때문입니다.

음, 이것이 기본입니다. 이제 만약 제가 여러분에게 "오셔서 TDD 워크숍을 해달라"고 가르친다면, 저는 이것을 시작점으로 가르칠 겁니다. 실용주의자 데이브(Pragmatic Dave)는 막 시작한 훌륭한 서브스택(Substack)을 가지고 있는데, 그는 자신의 개인적인 작업 흐름에 대해 이야기합니다. 그의 개인적인 작업 흐름에는 테스트를 쓰지 않는 때도 있고, 나중에 테스트를 쓰는 때도 있습니다. 그것이 바로 '숙달(mastery)'입니다. 그리고 언제 무엇을 할지 의식적으로 결정하지 않는 경지에 도달하는 것. 판단력과 직관이 이끌도록 내버려 두는 것. 그것은 강력한 경지입니다. 하지만 거기에 도달하려면 먼저 음계를 좀 연주해야 합니다. 이 작업 흐름을 따르는 것이 바로 프로그래밍의 음계입니다. 음악이 아니고요. 이것은 시작점입니다. 확실히 비판의 대상이 될 수 있는 곳이고요. 만약 여러분이 TDD를 이런 식으로 이해하지 못했다면, 한번 시도해 보시길 바랍니다. 시도해보고 효과가 있거나 없거나, 혹은 문제를 발견한다면, 그에 대해 듣고 싶습니다. 하지만 이것이 바로 제가 오리지널 TDD 책에서 설명하려고 했던 것이고, 지난 25년 동안 설명하려고 노력해 온 것입니다. 그리고, 자, 우리는 여기에 있습니다. 네. 시간 내주시고 주목해 주셔서 정말 감사합니다.

[박수]

[사회자]
정말 감사합니다, 켄트. 음, 질문이 굉장히 많네요. 안타깝게도 모든 질문을 다룰 시간은 없을 것 같습니다. 가능하시다면 아주 짧게 답변해 주시길 부탁드립니다.

[켄트 벡]
알겠습니다.

[사회자]
스택 예제에서, 사전에 몇 개의 테스트를 작성하시겠습니까?

[켄트 벡]
하나요.

[사회자]
좋습니다. 이 답변에 놀라신 분 있나요? 알겠습니다. TDD는 단위, 통합, E2E 등 다양한 추상화 수준의 테스트에서 어떻게 작동하나요?

[켄트 벡]
저는 신경 쓰지 않습니다. 저는 항상 여러 수준을 넘나들거든요. 큰 문제를 해결하기 위해 이 부분과 저 부분을 해결하면 둘의 조합이 전체 문제를 해결할 것이라고 생각하는 분해(decomposition)에는 분명 기술이 필요합니다. 하지만 그런 분해에서 실수를 할 수도 있죠. 그래서 저는 나무가 자라듯, 전체 문제를 먼저 해결하고 그 다음에 세분화하는 것을 선호합니다. 하지만 강연 자체에 그 원칙을 적용했던 것처럼, 우리는 동일한 원칙들을 적용할 수 있습니다. 저는 "우리가 원하는 최종 결과물은 무엇인가?"라고 질문했죠. 우리는 코드 뭉치와 테스트 뭉치를 원하고, 자신감을 느끼고 싶어 합니다. 그게 우리가 원하는 최종 목표죠. "좋아, 그럼 거기에 어떻게 도달할 것인가?" 이게 바로 그와 같은 종류의 생각입니다. 감사합니다.

[사회자]
어떻게 제 코드보다 테스트를 더 신뢰할 수 있나요?

[켄트 벡]
오, 그럴 수 없습니다. 회계사들은 이를 '교차 검증(cross-footing)'이라고 부릅니다. 만약 제가 숫자 행렬을 가지고 있고, 행별로 더한 다음 열을 따라 더하고, 열별로 더한 다음 행을 가로질러 더해서 같은 답을 얻었다고 해도, 저는 여전히 제 산수에서 정확히 상쇄되는 오류를 저질렀을 수 있습니다. 하지만 그럴 확률은 훨씬 작죠. 저는 제 테스트를 믿지 않습니다. 저는 제 코드를 믿지 않습니다. 그렇기 때문에 저는 두 개의 다른 경로를 통해 같은 답에 도달하고 싶은 것입니다. TDD에 대한 죄악 중 하나는 코드를 작성하고, 실제 결과를 출력해서 테스트에 붙여넣는 것입니다. 당신은 아무것도 이중으로 확인하지 않은 겁니다. 당신이 한 일은 그 답이 바뀌지 않도록 보장한 것뿐입니다. 하지만 그것은 완전히 다른 이야기죠. 예를 들어 보험 계리사가 숫자를 계산하게 하고, 우리가 코드로 숫자를 계산해서 둘이 일치한다면 우리는 훨씬 더 자신감을 갖게 될 겁니다. 실패하는 테스트가 있는데 그 실패가 놀랍다면, 아마 3분의 1은 테스트에 문제가 있는 경우이고, 3분의 2는 코드에 문제가 있는 경우일 겁니다. 이건 제 개인적인 관찰입니다. 이것도 석사 논문 프로젝트로 정말 멋질 것 같네요. 어딘가에서 TDD를 측정해서 테스트가 깨지는 비율과 코드가 깨지는 비율이 얼마인지 알아내고, 테스트 실패에 대한 분류 체계를 만들 수 있다면 정말 멋진 프로젝트가 될 겁니다. 저는 안 할 거지만요.

[사회자]
감사합니다. AI가 명세로부터 적절한 단위 테스트를 생성할 수 있을 때도 TDD는 여전히 유효한가요?

[켄트 벡]
어제 경험에 비추어 볼 때, 오늘날 AI는 명세로부터 적절한 단위 테스트를 생성할 수 없습니다. 내일은 다를 수도 있겠죠. 음, TDD가 여전히 유효할까요? 저는 이 '지니(genie)'가 TDD의 부활이라고 생각합니다. 복잡성 이론의 의미에서 초기 조건에 민감한 비결정론적 시스템을 다룰 때마다, 그 시스템을 어느 정도 제어하는 방법은 항상 '억제(inhibition)'입니다. 무언가 일어나지 않도록 막아야 하죠. 그리고 저는 테스트가 지니가 어리석은 짓을 하는 것을 막는 훌륭한 방법이라는 것을 발견했습니다. 물론 지니가 테스트를 삭제하거나, 주석 처리하거나, 단지 단언(assertion) 부분만 주석 처리하면 테스트가 통과한다는 것을 알아챌 때는 예외입니다. 그래서 저와 지니는 가끔 그 문제에 대해 이야기를 좀 나눠야 합니다. 하지만 프로그래머로서 당신이 명시하는 테스트는, 해결책의 범위를 한정하는 방법으로 사용됩니다. 지니는 온갖 종류의 해결책을 내놓을 겁니다. 당신이 프로그래머로서 명시하는 테스트는 "아니, 아니, 아니, 아니, 이런 것들만 좋은 코드야. 네가 원하는 코드를 만들되, 이 요구사항들을 만족시켜야 해"라고 말하는 방법인 거죠.

[사회자]
감사합니다. 마지막 질문입니다. 음, 만약 제가 많은 시나리오를 알고 있어서 많은 테스트를 먼저 작성한다면 어떻게 될까요?

[켄트 벡]
그렇게 하지 마세요. 시나리오를 알고 있더라도, 테스트 1, 2, 3, 4를 작성하고 그 사이에 코드를 넣는 데 아무런 비용이 들지 않습니다. 그러니 왜 미리 다 하시겠습니까? 왜 기다리지 않으시죠? 왜냐하면 기다리다가 새로운 것을 발견하게 될 수도 있기 때문입니다. 저는 항상 제가 무지하고 무언가를 배울 것이라는 데 걸겠습니다. 실제 테스트 작성을 미루는 것은 제가 배울 더 큰 기회를 주고, 진행하면서 마찰을 줄여줍니다.

[사회자]
답변이 빨랐네요. 그럼 하나 더 가겠습니다. 속성 기반 테스트(property based testing) 같은 기술이 TDD와 잘 맞는다고 생각하시나요? 아니면 테스트가 통과하는 상태에서 일반화 단계를 너무 고통스럽게 만드나요? 대부분의 테스트를 통과시키려면 실제 구현이 필요할 수 있으니까요.

[켄트 벡]
제가 속성 기반 테스트에서 느끼는 어려움은, 그리고 저는 속성 테스터를 작성하고 사용해봤습니다만, 저에게 문제는 복잡성 분할입니다. 이 복잡성은 여기에, 저 복잡성은 저기에 두고, 모든 것을 한 번에 삼키는 대신 한 번에 한 덩어리씩 처리할 수 있는 아이디어 말입니다. 만약 제가 속성 기반 테스트를 먼저 작성한다면, 테스트 통과에서 오는 도파민 분출을 느끼기 전에 구현을 끝내야 합니다. 저는 속성 기반 테스트를 싫어하지는 않습니다. 어제 저는 일종의 데이터 구조인 B+ 트리를 작업하고 있었는데, 속성 테스트로 마무리했습니다. 하지만 거기서 시작하지는 않았죠. 저는 구체적인 것부터 시작했습니다. 항목을 하나 삽입하고, 두 개, 네 개, 다섯 개를 삽입하면 이제 달라지는 식으로요. 그래서 속성 기반 테스트는 제자리가 있다고 생각하지만, 발견의 작업 흐름에서는 부분적이고 구체적인 진전을 이루기 어렵게 만든다고 생각합니다. 그건 저의 경우이고, 다른 사람들은 완전히 다르게 생각할 수도 있습니다.

[사회자]
정말 감사합니다, 켄트. 큰 박수 부탁드립니다.
[박수]
감사합니다. 정말 감사합니다. 여기 작은 선물이 있습니다.

[켄트 벡]
오, 정말 감사합니다. 저를 데려와 주셔서 정말 감사합니다.