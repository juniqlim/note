# Refactoring.fm - Kent Beck Interview
https://youtu.be/G6uBAwVrxHw?si=hlzEDzVqPdOCN2Rt  
켄트벡 인터뷰 영상의 스크립트를 번역한 내용입니다. gemini 2.5 pro를 이용했습니다.

---

켄트 벡: 어, 애자일이 등장했고, 잠시 동안은 위협처럼 보였습니다. 그래서 권력 구조가 그것을 자기 것으로 편입시켰고, 더 이상 위협이 아니게 되었습니다. 이제 가치의 자기 몫 이상을 뽑아내던 사람들은 여전히 자기 몫 이상을 뽑아낼 수 있고, 바닥에서 부스러기를 주워가며 일하던 사람들은 여전히 부스러기를 줍고 있습니다. 그래서 권력 구조의 관점에서 보면 모든 것이 괜찮습니다. 우리는 현상 유지로 돌아온 것이죠.

오늘의 게스트는 애자일 선언문의 원조 서명자이자 익스트림 프로그래밍의 창시자이며, 전방위적인 프로그래밍의 전설인 켄트 벡입니다. 이 대화에서 우리는 2024년 애자일의 현주소와 그것이 어떻게 권력 구조에 의해 다소 변질되었는지에 대해 논의합니다. 우리는 심리적 안정감, 짧은 피드백 루프, 그리고 엔지니어의 주인의식의 중요성에 대해 이야기합니다. 우리는 회사의 여러 단계에서 애자일에 대한 다양한 접근 방식을 탐구하고, 소프트웨어 개발에서 AI가 제시하는 도전과 기회에 대해 논의합니다. 그럼 스폰서의 짧은 말씀을 들은 후 바로 시작해 보겠습니다.

이 에피소드는 원 스키마(One Schema)의 후원으로 제작되었습니다. 원 스키마는 SaaS를 위한 내장형 CSV 임포터로, 팀이 수개월의 개발 시간을 절약하도록 돕습니다. 회사들은 종종 CSV 임포터를 구축하는 데 1인-월(engineer-month)을 계획하지만, 고객이 사용할 수 있는 모든 기능을 구축하는 데는 3개월에서 6개월 이상이 걸리는 경우가 많습니다. 고객 파일은 예상치 못한 데이터와 형식으로 가득 차 있으며, 오류를 쉽게 수정할 수 있는 UI와 같은 핵심 기능이 없으면 가져오기 성공률이 급격히 떨어지고 지원팀에 끝없는 이메일을 유발합니다.

원 스키마를 만나보세요. 대규모의 사전 구축된 유효성 검사 라이브러리와 견고한 SDK를 통해 원 스키마는 몇 분기가 아닌 몇 시간 만에 CSV 가져오기 기능을 출시할 수 있도록 돕습니다. 고객들이 여러분 제품의 가치를 몇 분 안에 경험하게 하고, "53번 줄 가져오기 오류"와 같은 답답한 메시지와 작별하게 하세요. 이제 깨끗한 고객 데이터를 제품으로 가져오는 것이 그 어느 때보다 쉬워졌습니다. oneschema.co를 방문하여 더 자세히 알아보세요.

안녕하세요, 켄트. 오늘 함께해주셔서 정말 감사합니다.

켄트 벡: 루카, 제 기쁨입니다. 당신과 처음으로 직접 이야기하게 되어 정말 좋습니다.

루카: 네, 드디어 만났네요. 정말 기쁩니다. 여쭤보고 싶은 게 정말 많아요. 아마 하루 종일 여기 있을 수도 있겠지만, 그러지 않겠다고 약속합니다.

켄트 벡: 저도 약속하죠.

루카: 네, 그럼 바로 본론으로 들어가겠습니다. 음, 제가 당신과 가장 먼저 이야기하고 싶은 것은, 당신처럼 업계에 오랫동안 몸담아 온 분과 대화할 수 있다는 것이 정말 큰 영광이라는 점입니다. 당신은 엔지니어링 작업을 어떻게 할 것인지, 소프트웨어를 어떻게 작성할 것인지에 대한 다양한 사고방식의 여러 시대를 살아오셨습니다. 그래서 저는 좀 더 큰 그림으로 시작하고 싶습니다. 당신은 2001년 애자일 선언문의 17명의 원조 서명자 중 한 분이시죠.

켄트 벡: 제가 그냥 한 명이 아니라, 제가 첫 번째입니다.

루카: 첫 번째...

켄트 벡: 알파벳 순서이긴 하지만요.

루카: 알파벳 순서라도 첫 번째는 중요하죠. 그럼 당신은 애자일 선언문의 첫 번째 서명자라고 하겠습니다. 이건 편집할 테니, 그냥 당신이 선언문의 첫 번째 서명자라고 말하겠습니다.

켄트 벡: 아니, 괜찮아요. 전 그 농담 좋아합니다.

루카: 그리고 애자일에 관해서 제 느낌은, 오늘날 그 단어 자체가 너무나 흔해서 때로는 그 의미의 일부를 잃어버린 것 같다는 겁니다. 아시죠, 마치 어떤 단어를 여러 번 소리 내어 말하면 잠시 후 머릿속에서 그 의미를 잃어버리는 것처럼요. 그리고 최근 당신의 인터뷰를 보면, 심지어 워터폴(waterfall) 방식이 어떤 환경에서는, 심지어 스타트업에서도 슬그머니 다시 돌아오고 있다고 말씀하셨더군요. 그래서 제 질문은, 2024년 애자일의 현주소는 어떻다고 생각하시나요? 당신이 원했던 모습인가요?

켄트 벡: 제가 원했던 모습이라는 건 없습니다. 소프트웨어 개발은 확실히 대부분 끔찍하고, 그건 제가 원했던 게 아닙니다. 그건 제가 원하는 게 아니에요. 네. 음, '애자일'이라는 단어의 문제는 너무 매력적이라는 겁니다. 제가 익스트림 프로그래밍(extreme programming)이라는 이름을 만들었을 때 사람들이 불평했었죠. 그 이름은 확실히 장단점이 있습니다. 하지만 당신이 익스트림 프로그래머가 되기 위한 실제 힘든 노력을 하지 않았다면, 당신은 절대로 익스트림 프로그래머라고 주장하지 않을 겁니다. 왜냐하면 좀 민망하니까요. 하지만 '애자일'은 모두가 애자일하고 싶어 합니다. 누구도 경직되거나 융통성 없게 보이고 싶어 하지 않죠. 그래서 아무도 자신이 애자일하지 않다고 말하지 않을 겁니다. 그래서 바로 그 점에서... 그리고 저는 그 회의에서 이 단어는 브랜드로서 방어할 수 없다고 말했습니다. 모두가 자기 것으로 편입할 것이기 때문에 방어할 수 없다고요. 그리고 정확히 그렇게 되었습니다. 그래서 놀라지 않았고, 실망하지도 않았습니다.

하지만 지금 제가 보는 방식은 이렇습니다. 작동하는 권력 구조가 있고, 그 권력 구조는 자신의 권력을 방어합니다. 그런데 애자일이 등장했고, 잠시 동안은 위협처럼 보였습니다. 그래서 권력 구조가 그것을 자기 것으로 편입시켰고, 이제 더 이상 위협이 아니게 되었습니다. 이제 가치의 자기 몫 이상을 뽑아내던 사람들은 여전히 자기 몫 이상을 뽑아낼 수 있고, 바닥에서 부스러기를 주워가며 일하던 사람들은 여전히 부스러기를 줍고 있습니다. 그래서 권력 구조의 관점에서 보면 모든 것이 괜찮습니다. 우리는 현상 유지로 돌아온 것이죠.

루카: 네, 그렇다면 그것이 현상 유지에 어떤 위협이었다고 생각하시나요? 의사 결정 과정에 참여하지 못하거나 게임에 끼지 못했던 사람들에게 힘을 실어준다고 느끼셨기 때문인가요?

켄트 벡: 네, 예를 들어, 저는 괴짜(geek)니까 프로그래머의 관점을 취하겠습니다만, 만약 당신이 "프로그래머는 다음에 무엇을 할지 선택하는 데 중요한 역할을 한다"고 말한다면, 그것은 권력 구조가 원하는 것과 정반대입니다. 권력 구조는 매우 명료하죠. 제가 문제를 가져와서 조각으로 나누고, 그 조각들을 질문하지 않고 그저 완벽하게 제시간에 실행하는 사람들에게 나눠줍니다. 그들이 조각들을 돌려주면 제가 모든 것을 통합하고, 그러면 끝이고 모든 것이 괜찮습니다. 현실은 그렇게 작동하지 않지만, 당신이 권력자라면 모두가 그렇게 작동하는 척하도록 강요할 수 있습니다. 그리고 그것이 바로 우리가 되돌아간 모습입니다.

소프트웨어 개발이 발견과 실행이 복잡하게 얽힌 소용돌이이며, 개인의 관계가 전체 제품의 궤도에 엄청나게 중요하다고 기대하는 것과는 대조적이죠. 통제할 수 있는 방식은 아니지만, 격려할 수 있는 방식으로는요. 의사 결정과 권력의 중심에 익숙한 사람에게는 그것이 매우 통제 불가능하게 느껴질 겁니다. "와, 그럼 내 역할은 뭐지?" 싶겠죠. 사실 매우 중요한 역할이지만, 대부분의 사람들은 그 역할을 선택하지 않습니다. 그래서 저는 그런 역학을 봅니다. 그리고 당신이 "권력 구조는 스스로를 재주장할 것이다"라고 말하는 순간, 워터폴은 그 권력 구조의 아름다운 표현입니다. 우리는 우리가 무엇을 할지 정확히 말할 겁니다. 당신은 그럴 수 없죠. 왜냐하면 당신은 무엇을 할지 모르니까요. 네, 그리고 설령 안다고 해도, 돌이켜보면 그것이 당신이 원했던 것이 아닐 겁니다. 하지만 그 워터폴은 매우 명료한 작업 구조이며, 책임은 당신에게 있고, 잘못된 것에 대한 보상은 제가 받고 처벌은 당신이 받는 식입니다. 그 권력 구조는 워터폴 방식에 매우 깊이 내재되어 있습니다. 그래서 같은 재료를 그릇에 넣으면 같은 케이크가 나오는 것에 놀라지 않습니다. 제가 했던 일의 일부는 새로운 재료 세트를 추천하는 것이었습니다. 그런데 옛 재료를 좋아하지만 케이크는 별로 좋아하지 않던 사람들은 "아니, 아니, 아니, 우린 저거 원하지 않아"라고 했죠.

네, 제가 마지막으로 코칭했던, 아니 관리했던 팀에서 제 상사가 와서 "이거 언제 끝나나요?"라고 물었습니다. 제가 "아무도 '이거'가 뭔지 모르는데 어떻게 답을 드리겠습니까?"라고 했더니, 그가 "네, 네, 원칙은 이해하고 감사합니다만, 그래서 언제 끝나죠?"라고 했습니다. 네, 그냥 답을 달라는 거죠. 저도 답을 줘야 하니까요. 그에게 연민을 느낍니다. 왜냐하면 그 역시 자신이 도저히 대답할 수 없는 질문들을 다른 사람들로부터 받고 있었기 때문입니다. 하지만 저는 그것을 제 팀에 떠넘기지 않을 겁니다. 제가 날짜를 말하는 순간, 저는 불이익만 있고 이익은 없습니다. 그 날짜를 맞추면 본전이고, 못 맞추면 큰일이죠. 그래서 저는 제 팀에 그런 인센티브를 만들지 않을 겁니다. 하지만 그런 환경에서 일하는 것은 엄청나게 스트레스가 많았습니다. 결국 편두통과 관절염에 시달리다 그만두었죠. "아니, 이런 환경에서는 일하고 싶지 않아"라고 생각했습니다.

하지만 제 상사가 제 관점에서 볼 때 바보 같은 질문, 즉 대답할 수 없는 질문을 받지 않고, 그가 답을 지어내거나 저에게 답을 지어내라고 위임할 필요가 없다고 느끼는 환경은 어떤 모습일까요? 그것은 현재의 표준적인 비즈니스 모델과는 다른 형태일 겁니다.

루카: 네, 정말 훌륭한 견해라고 생각합니다. 그리고 기술적으로는 발전하지만, 결국 엔지니어링은 사람들 간의 인간 관계에 관한 것이라는 점을 잘 보여줍니다. 그래서 문제는 수년, 수십 년이 지나도 변하지 않습니다.

켄트 벡: 사람들이 변하기 전까지는요. 프로그래밍 언어를 위한 더 나은 타입 시스템을 발명하는 것만으로는 변하지 않을 겁니다. 물론 아주 약간은 변할 수 있고, 괴짜로서 기술적 진보에 감사하지만요. 하지만 사람들이 한 형태의 권력을 다른 형태의 권력과 교환할 의지가 생기기 전까지는, 근본적으로 아무것도 바뀌지 않을 겁니다.

루카: 네, 그리고 아까 익스트림 프로그래밍(XP)을 언급하셨는데, 물론 당신의 가장 유명한 업적 중 하나죠. 익스트림 프로그래밍에서는 시간이 지나면서 성공적이라고 입증된 여러 실천법을 옹호하지만, 많은 맥락에서 여전히 논란의 여지가 있습니다. 페어 프로그래밍이나 TDD, 심지어 어떤 경우에는 지속적 통합(CI) 같은 것들이요. 이러한 실천법들이 여전히 저항에 부딪히는 것이 관계 역학 때문이라고 생각하시나요? 아니면 어떻게 생각하시나요?

켄트 벡: 100% 그렇습니다. TDD는 종교적인 논쟁거리가 되었죠. "나한테 테스트 작성하라고 강요하지 마!" 같은 반응을 보면, 저는 "당신에게 테스트 작성을 강요하려는 게 아닌데요"라고 생각합니다. 저는 신경 안 써요. 왜 저한테 소리치시는 거죠? 이런 대화를 파고들어 보면 반복해서 나타나는 주제가 있습니다.

그것은 저희가 JUnit을 소개하며 내세웠던 주제입니다. 우리는 "프로그래머는 자신들의 작업 품질에 책임이 있다"고 말했습니다. QA나 리뷰어가 아니라, 개별 프로그래머가 자신의 작업 품질에 책임이 있다는 겁니다. 그리고 제가 그냥 손가락질만 했다면 불공평했겠죠. 그래서 여기 JUnit이라는 도구가 있고, TDD와 같은 기술이 있습니다. 이것들이 당신이 책임감을 갖도록 도와줄 겁니다. 왜냐하면 당신은 지금 많은 실수를 저지르고 있고, 그 실수들은 다른 사람들에 의해 매우 긴 시간 간격으로 처리되고 있기 때문입니다. 그럼 어떻게 하면 그 실수들을 더 빨리 잡아낼 수 있을까요? 어떻게 하면 하류로 넘어가는 결함의 수를 줄일 수 있을까요? 만약 당신이 책임감을 갖고 자신의 실수의 결과에 실제로 대처하고 싶다면, 당신이 저지르는 실수의 수를 줄이게 될 겁니다. 그리고 TDD에 대한 가장 감정적인 반응을 보이는 대화들을 보면, 사람들은 반복해서 "저는 제 작업의 품질에 책임을 질 수 없어요. 만약 오류가 있다면 다른 누군가가 그 대가를 치러야 할 겁니다"라고 말합니다.

제게는 그것이 일, 자기 자신, 동료, 고객과의 관계에서 매우 역기능적인 모습으로 보입니다. 자신의 실수 결과를 다루는 것이 불편하다는 것은 이해합니다. 하지만 "난 못 해"라고 말하며 손을 씻어버리는 것보다는 훨씬 낫습니다.

루카: 네, 그건 정말 훌륭한 관점이네요. 이런 각도에서는 생각해 본 적이 없었어요. 그러니까 기본적으로 '벌거벗은 임금님' 같은 경우라고 생각하시는 거군요. TDD를 하면 자신의 책임과 마주하게 되고, 일을 허술하게 할 수 없게 된다는 거죠. 많은 프로그래머들이 인정하고 싶어 하는 것보다 더 자주 그렇게 할 텐데요.

켄트 벡: 물론이죠. 우리 모두 압박을 받고 있으니까요. 모든 것이 더 빨리, 더 일찍, 더 싸게, 더 좋게 이루어져야 합니다. 그리고 만약 더 빨리, 더 일찍, 더 싸게, 더 좋게 진행 상황을 보고하라는 압박만 있다면, 당신은 진행 상황에 대한 보고는 받겠지만, 실제로 더 빨리, 더 일찍, 더 좋게, 더 싸게 되지는 않을 겁니다. 그래서 제가 항상 상향식(bottom-up)으로 일하는 한 가지 이유는 바로 그것입니다. 저는 손가락질하며 "버그를 너무 많이 만들고 있어!"라고 말하지 않을 겁니다. 대신 결함을 더 빨리 찾을 수 있는 방법, 근본 원인을 제거하는 방법, 실수를 했을 때 알려주는 피드백 루프를 갖는 방법에 대해 이야기할 겁니다. 그러면 실수를 공개적으로 드러내기보다 개인적으로 처리할 수 있게 되죠.

루카: 네, 그리고 언급하신 압박에 대해 말하자면, 어떻게 그 압박을 완화할 수 있을까요? 함께 일하는 사람들, 즉 아이디어나 요구사항, 해야 할 일들을 주고받는 사람들과 어떤 관계를 맺어야 엔지니어로서 압박을 덜 받을 수 있을까요? 채팅창에서도 질문이 올라오고 있네요. Dobs님이 "비즈니스 요구와 결과물, 예산 사이의 갈등을 어떻게 해결해야 하나요?"라고 물으셨는데, 이것도 같은 맥락인 것 같습니다. 엔지니어들의 어깨에 지워진 압박에 대한 것이죠.

켄트 벡: 음, 엔지니어링에는 한 학파가 있습니다. 이건 제 아버지의 견해인데요, 아버지는 전기 기술자셨다가 프로그래머가 되셨죠. 저는 실리콘 밸리가 실리콘 밸리가 되기 전부터 그곳에서 자랐습니다. 아버지의 관점은 "그냥 나 좀 내버려 둬. 난 내 일을 할 거야. 아주 잘할 테니, 날짜가 되면 결과물을 받게 될 거야. 그냥 내 눈앞에서 사라져 줘." 꽤나... 뭐랄까... 대립적인 방식이죠. 그리고 엔지니어로서 실력이 충분히 좋다면 어느 정도는 통할 수 있지만, 결국에는 한계에 부딪힙니다. 그리고 때로는 실패할 때 크게 실패하죠.

XP는 거의 정반대의 접근 방식을 취합니다. 우리가 전달하고자 하는 가치를 가져와서 아주 작은 조각으로 나눕니다. 그리고 그 조각들을 사용해서 현재 우리를 신뢰하지 않는 사람들과 관계를 구축합니다. 비즈니스는 프로그래머를 신뢰하지 않습니다. 우리는 약속을 하고 지키지 않는 경우가 허다하죠. 40년 동안이나요. 이건 우리만의 잘못이 아니라 우리 부모님 세대, 그리고 그 부모님 세대의 잘못이기도 합니다. 이 역기능적인 관계를 만들어 온 거죠. 하지만 그 관계를 재건하는 방법은 다른 사람들이 중요하게 생각하는 기능을 정기적으로 전달하는 것입니다.

이는 우리가 평소와는 다른 방식으로 엔지니어링을 해야 한다는 것을 의미합니다. 예를 들어, 리팩토링이 필요할 때, 한 달 동안 모든 기능 개발을 중단하는 대신, 4개월에서 6개월에 걸쳐 기능을 전달하면서 조금씩 리팩토링을 진행하는 거죠. 비즈니스 측에서 무언가를 얻을 것이라는 사실을 알게 되면... 비즈니스 측의 가장 큰 두려움은 "이 모든 투자를 하고도 아무것도 얻지 못할 것이고, 마지막 순간까지 알 수 없어서 바보처럼 보일 것이다"라는 겁니다. 누군가를 그런 끔찍한 상황에 빠뜨리는 거죠. 그래서 저는 프로젝트 예산의 2%가 소진된 후에는 그들을 그 상황에서 벗어나게 하고 싶습니다. "오, 우리는 아무것도 얻지 못하는 게 아니구나. 지금 우리가 가진 것은 조잡하고 비효율적이며 확장성은 없지만, 지난주에는 해결할 수 없었던 비즈니스 문제를 오늘 실제로 해결하고 있잖아." "아, 그렇구나. 아무것도 못 얻는 게 아니었네. 알았어." 이런 식으로 우리는 진전을 이룰 수 있고, 방향을 조정하고 우선순위를 바꿀 수 있습니다.

"충분히 빠르지 않다"고 말할 힘은 없습니다. 그게 유일하게 할 수 없는 일입니다. 팀에 가서 "그냥 더 빨리 해야 해"라고 말하면, 보고서상으로는 순응하는 것처럼 보이겠지만, 당신이 구축하려고 노력해 온 모든 관계를 망치게 될 겁니다. 대신 "나에게 이런 필요가 있어", "비즈니스 담당자로서 이 필요가 충족되지 않을까 봐 두려워"라고 말할 수 있습니다. 그러면 엔지니어들은 당신과의 관계 수준에 따라 당신의 필요를 실제로 충족시키기 위해 활성화될 겁니다. 그것이 당신이 상상했던 바로 그 기능이 아닐 수도 있습니다. 문제를 해결할 다른 방법이 있을 수도 있죠. 하지만 서로를 더 신뢰할수록, 대화의 수준을 "이 구현, 저 구현"과 같은 낮은 수준에서 "필요(needs)"의 수준으로 끌어올릴 수 있습니다. 그러면 가치를 창출하는 방법에 대한 손발이 묶이지 않게 되죠. 질문에 대한 답이 되었나요?

루카: 물론입니다. 제 비교적 짧은 경험에서도, 대화의 초점을 최종 예측치나 최종 결과물에서 주 단위나 2주 단위로 작동하는 프로세스로 옮길 수 있다면, 비즈니스 담당자들도 매주 또는 2주마다 사용자에게 가치를 창출하는 유용한 무언가를 얻게 되고, 그러면 최종 결과물에 대한 압박은 훨씬 줄어듭니다.

켄트 벡: 매주요. 매주 해야 합니다. 2주는 너무 길어요. 영원처럼 느껴지죠.

루카: 영원처럼 느껴지죠. 그리고 만약 그렇게 할 수 있다면, 제가 말하려던 것은 최종 결과물에 대한 압박과 관심이 사라진다는 겁니다. 훨씬, 훨씬 줄어들죠.

켄트 벡: '최종'이라는 말은 실패를 의미합니다. 만약 소프트웨어 시스템이 있는데 비즈니스가 더 많은 이익을 얻기 위해 더 투자할 방법이 없다면, 그 시스템은 이제 죽은 겁니다. 그게 바로 실패죠. 하지만 그런 사고방식의 전환... 제가 차를 사는데 차가 거기에 없다면, 저는 차가 없는 거죠. 이 점은 매우 명확합니다. 만약 제가 어떤 소프트웨어 개발을 구매했는데, 그 일부가 도착해서 이미 제 자신을 이동시킬 수는 있지만, 제 차만큼 빠르지는 않고... 계속해서 매주 더 좋아진다면, 우리는 더 강한 신뢰를 쌓게 됩니다.

루카: 네, 물론입니다. 그게 바로 제가 일하고 싶은 세상입니다. 그리고 저는 애자일 조언이나 XP 조언이 얼마나 자주 무언가를 더 자주 하는 것에 관한 것인지가 재미있다고 생각합니다. 거의 모든 것에 대해 더 짧은 피드백 루프를 만드는 거죠. 고객과 더 자주 이야기하고, 코드를 더 자주 배포하고, 코드를 더 자주 검토하고, 페어 프로그래밍을 통해 코드를 지속적으로 검토하는 것 등 모든 것이요. 모든 것을 더 빨리 하는 것이 아니라 더 작은 반복, 더 작은 묶음으로 하는 거죠.

켄트 벡: 맞습니다. 그러면 낭비가 줄어들고, 결과적으로 같은 시간에 더 많은 것을 성취하게 됩니다. 더 빨리 움직여서가 아니라, 낭비되는 움직임이 줄었기 때문이죠. 그리고 그 한계에 부딪힐 때마다... 이 2주 대 1주 논쟁은 정말 저를 미치게 합니다. "우리는 일주일 안에 사용자가 신경 쓰는 어떤 것도 성취할 수 없어." 당신이 '씽키(Thinky)'를 읽고 있군요, 맞죠?

루카: 네, 맞아요.

켄트 벡: 제 유료 서브스택 구독자들은 매주 '씽키'를 받습니다. 이건 제가 모으기 시작한 창의적 사고 습관이죠. 바로 여기에 원본이 있습니다. 아이디어가 떠오르고 그 출처를 알 때마다 여기에 생각의 요령을 적어두곤 했죠. '씽키' 중 하나는 "할 수 없어, 왜냐하면('can't because')"입니다. 누군가가 "Y 때문에 우리가 하고 싶은 X를 할 수 없어"라고 말할 때마다, 항상 그 말을 뒤집어서 "Y가 더 이상 사실이 아닐 때, 우리는 X를 할 수 있을 거야. Y를 더 이상 사실이 아니게 만들려고 노력할 가치가 있을까?"라고 생각해 보는 겁니다.

"우리는 일주일 안에 사용자가 신경 쓰는 어떤 것도 성취할 수 없어. 따라서 우리는 2주 스프린트를 해야 해." 이것이 완벽한 '할 수 없어, 왜냐하면'의 예입니다. 이것을 뒤집으면, "우리가 매주 사용자가 신경 쓰는 무언가를 성취할 수 있을 때, 우리는 1주 스프린트를 할 수 있을 거야."가 됩니다. "오, 알았어. 그럼 그렇게 하려면 뭐가 필요할까? 우리 시간이 어디에 쓰이는지 한번 보자." 소프트웨어 개발 시간의 90%, 95%는 작업 항목이 어떤 큐에서 그냥 기다리는 시간입니다. 그러니 우리가 가진 핸드오프(handoff)들과 왜 그런 핸드오프가 필요한지, 그리고 그 핸드오프가 필요 없도록 작업을 어떻게 다르게 배열할 수 있는지 살펴봅시다. 그러면 큐를 없애고 대기 시간을 줄여서, 금요일까지 사용자가 신경 쓰는 무언가를 실제로 성취할 수 있습니다.

매주 주말에 "내가 한 일 때문에 다른 사람들을 위한 시스템이 더 좋아졌어"라는 사실을 알고 주말을 맞이하는 것은 정말 멋진 기분입니다. 그러면 주말 내내 그 생각을 곱씹다가, 일요일 오후 4시쯤 되면 "좋아, 이제 시작해볼까"하는 마음이 들고, 월요일 아침에는 못이라도 씹어 먹을 기세로 출근하게 됩니다. "나한테 맡겨!" 하는 거죠. 정말 멋진 기분인데, 왜 그걸 안 하려고 할까요? 하지만 어떤 이유에서인지 사람들은 "우리는 일주일 안에 아무것도 성취할 수 없어"라고 말합니다.

루카: 네, 왜냐하면 때때로 사람들은 무언가를 성취한다는 것이 매우 완성도 높은 것을 출시하는 것이라고 생각하기 때문인 것 같아요. 그게 일종의 최종 결과물 중심의 사고방식이죠. 반면에, 채팅창에 있는 R님의 의견과도 연결되는데, "무언가가 사람들의 머릿속에만 있을 때는 모두가 다르게 볼 수 있지만, 불완전하고 미완성이더라도 밖으로 꺼내놓으면 대화에 도움이 된다"는 말은 정말 옳다고 생각합니다. 그것을 어떻게 개선하고 더 좋게 만들지에 대한 대화의 기준점이 되기 때문이죠.

켄트 벡: 사람들 사이의 대화에서 그 질문이 제가 예상했던 것과는 다른 방향으로 갔네요. 저는 "모두의 머릿속에 다르게 있는 한, 그리고 그것을 구체화하지 않는 한, 갈등을 다룰 필요가 없다"는 쪽으로 갈 줄 알았어요. 네, 저는 시스템을 상상하고, 당신도 시스템을 상상할 수 있는데, 그 둘이 다르다는 사실은 중요하지 않죠. 하지만 그것을 구체화하고 예시를 내놓는 순간, "그건 그렇게 생기지 않았는데"라는 말이 나오고, 저는 "아니, 분명히 이렇게 생겼어"라고 말하게 되죠. 그러면 우리는 사물을 다르게 본다는 사실을 다루어야 합니다. XP의 세계에서는 모든 참여자에게 그 대화를 안전하게 만드는 것이 목표입니다. 왜냐하면 사람들이 미래를 똑같이 보지 않을 것이고, 심지어 현재도 똑같이 보지 않을 것이기 때문에 그것은 불가피합니다. 그러니 모든 것을 테이블 위에 올려놓고 다음에 무엇을 할지 결정합시다.

루카: 네, 그것이 XP 환경을 만들 수 있는 기반이라고 생각하시나요? 즉, 심리적 안정감, 다른 견해에 대해 건전한 갈등을 가질 수 있다는 신뢰, 그리고 만약 그 기반이 있다면...

켄트 벡: 네, 제 생각에 그 기반은 예측 가능성이라는 환상을 버리고 적응 능력을 창조하려는 의지를 가진 조직 전체입니다. 제가 항상 사용하는 비유는, 파도를 다루기 위해 방파제를 쌓을 것인가, 아니면 서핑하는 법을 배울 것인가 하는 것입니다. 방파제를 쌓고 그 뒤에서 바다가 잔잔한 척할 수 있습니다. 캘리포니아에서 지난 몇 주간 겪었던 폭풍이 오기 전까지는 그게 통했죠. 아니면 서핑을 배우는 겁니다. 패들을 저어 나가서 "좋아, 여기 온갖 변화가 일어나고 있네. 나는 이 변화에 적응하는 데 능숙해질 거야"라고 생각하는 거죠. 그러면 파도가 어떤 모습이든 상관없이 서핑을 할 수 있게 됩니다. 작은 파도든 큰 파도든 서핑할 수 있죠.

루카: 완벽한 비유라고 생각합니다.

켄트 벡: 하지만 조직 전체가 서핑을 배울 준비가 되어 있어야 합니다.

루카: 네, 규모가 다른 회사들, 예를 들어 다양한 회사에서 일하셨잖아요. 페이스북에서도 고성장기에 아주 오랫동안 계셨고요. 스타트업이 본질적으로 이런 사고방식을 받아들이기에 더 적합하다고 생각하시나요? 아니면 빅테크보다요? 제품 단계나 팀 규모는 중요하지 않은가요?

켄트 벡: 아니요, 저는 그게 매우 중요하다고 생각합니다. 저는 3X 모델, 즉 탐색(Explore), 확장(Expand), 추출(Extract) 모델에서 이에 대해 이야기합니다. 이 모델은 엔지니어, 관리자, 제품 관리자, 투자자로서 당신이 새로운 가치의 원천을 탐색할 때, 그리고 무언가 대박이 났을 때, 그리고 그것을 추출할 때 얼마나 다르게 행동해야 하는지에 대해 이야기합니다. 시작하기 전에 당신과 이야기했던 renkent 캠프, 즉 제가 쓴 모든 것을 넣어 제 관점에서 얼마나 좋을 수 있는지 보려고 만드는 이 개인화된 모델에 대해 말했었죠.

오늘 아침에 그것이 우리가 이전에 보지 못했던 방식으로 성공을 거두었습니다. 사람들이 더 길고 확장된 대화를 나누고, 답변은 때때로 흥미롭지만 종종 완전히 엉뚱했던 것에서 대부분 꽤 괜찮아졌습니다. "오케이, 이제 우리는 이 확장 단계에 있구나." 이제 "이 순간을 활용하기 위해 가능한 한 많은 사람들에게 가능한 한 빨리 그것을 어떻게 전달할 수 있을까?" 하는 거죠. 하지만 이것은 매우 다양하고 창의적인 작은 실험들을 많이 시도하는 단계와는 매우 다른 스타일의 엔지니어링, 다른 스타일의 관리, 다른 자금 조달 방식입니다.

그리고 추출 단계는, 이제 성장이 로켓처럼 치솟는 대신 예측 가능해졌을 때입니다. 성장이 예측 가능해졌을 때, 어떻게 거기서 자원을 빼내어 다음 단계에 투입할 수 있을까요? 그리고 정말 성숙하고 효과적인 회사들은 이 세 단계의 차이점을 인식하고, 그들이 하는 모든 개발 작업을 같은 상자에 넣으려고 하지 않습니다. 그것이 제가 2,000명 규모의 페이스북에서 배운 교훈이었습니다. 그 규모에서 세 단계를 동시에 능숙하게 다룰 수 있다는 것은 정말 대단한 일이었죠. 그리고 제가 떠날 때쯤인 2017년에는 전혀 그렇지 않았습니다. 모든 프로젝트가 매우 추출 중심이었고, ROI를 증명해야 했죠. 물론 그건 다 지어낸 숫자였지만, 갑자기 그냥 이것저것 시도해보고 안 되면 버리는 대신 숫자를 지어내야 했습니다.

루카: 네, 유튜브에서 본 3단계에 대한 당신의 강연을 정말 좋아했습니다. 그리고 많은 문제는 때로는 '여기까지 오게 한 것이 저기까지 데려다주지는 않는다'는 사실을 깨닫지 못하는 데서 비롯된다고 생각합니다. 다른 스타일과 접근 방식이 필요하죠.

켄트 벡: 그리고 그것은 인간의 본성과도 상충됩니다. 당신이 여러 가지 미친 아이디어를 시도해보고 그중 하나가 성공하면, 더 많은 미친 아이디어를 시도하고 싶어지죠. 네, 그리고 정말 잘 되던 그 하나는 당신이 확장하지 못해서 죽게 됩니다.

루카: 네, 맞아요. 페이스북 이야기가 나와서, 채팅창에서 Clemens가 물어본 엔지니어링 측면의 질문을 하나 하고 싶습니다. Clemens는 "왜 아무도 스택드 디프(stacked diffs)를 하지 않나요? 표준 깃허브 플로우보다 훨씬 나은 것 같은데 말이죠."라고 물었습니다. 페이스북이나 우버, 다른 빅테크 기업들이 그렇게 한다는 전설 같은 이야기가 있지만, 아직 우리 같은 평범한 사람들에게는 퍼지지 않았죠.

켄트 벡: 좋아요, 스택드 디프에 대한 제 화끈한 의견을 말씀드리죠. 제가 어떤 면에서 완성된 작업 조각을 마쳤다고 합시다. 제 생각에 모든 디프(diff)는 배포 가능해야 합니다. 좋아요, 이건 배포 가능합니다. 하지만 저는 계속 작업하고 싶습니다. 그런데 블로킹(blocking) 방식의 비동기 코드 리뷰를 기다려야 합니다. 어쨌든 이건 완전히 다른 주제이니, 제가 잠시 멈추면 원래 주제를 상기시켜 주세요.

음, 저는 계속하고 싶습니다. 그래서 첫 번째 디프가 이미 수락된 것처럼 다음 디프 작업을 시작할 겁니다. 그런데 첫 번째 디프에 대한 피드백을 받고 수정해야 한다면 어떻게 될까요? 그러면 그 다음 디프도 수정해야 합니다. 이건 마치 CPU의 추측 실행(speculative execution)과 같습니다. 마치 우리가 이미 이 메모리 위치를 가져온 것처럼 진행하고, 만약 그 가정이 틀렸거나, 분기 예측과 같은 경우죠. 우리는 이 테스트가 참을 반환할 것처럼 이 분기를 택하고, 만약 거짓을 반환하면 우리가 했던 모든 작업을 취소하는 겁니다.

제가 보기에 스택드 디프는 프로그래머로서 코드 리뷰가 어느 정도만 블로킹되도록 해줍니다. 저는 여전히 "코드 리뷰를 안 할 수는 없을까?"라는 질문을 갖고 있습니다. 코드 리뷰에 대한 원 논문을 다시 읽어보세요. 얼마 전에 누군가에게 참고 자료로 보냈는데, 지금은 기억이 안 나네요. 나중에 찾아서 쇼 노트에 넣을 수 있을 겁니다. 만약 그런 식으로 리뷰를 하고 싶다면, 그건 코드 리뷰죠. 팀의 모든 사람이 당신의 디프를 보고 몇 시간 동안 꼼꼼히 살핀 다음, 한 방에 모여서 당신이 제안한 변경 사항의 모든 줄에 대해 몇 시간 더 토론하는 겁니다. 저는 그 과정이 지독하게 지루할 것이라고 상상하지만, 많은 가치를 창출할 것이라고 생각합니다.

하지만 제 생각에, 이 블로킹 방식의 비동기 코드 리뷰 스타일, 즉 협업을 위한 워크플로우를 맹목적으로 따라 하는 것이 훨씬 더 큰 문제라고 봅니다. 우리가 지불하는 막대한 비용 없이 동일한 필요를 충족시킬 다른 방법들이 있다고 생각합니다.

루카: 네, 제게는 "이게 최선이니 이렇게 해야 한다"고 느낄 만한 해결책은 없지만, 가끔은 우리가 CI/CD 프로세스에서 10분이나 15분을 단축하기 위해 엄청난 노력을 기울이면서, 코드가 몇 시간, 때로는 며칠 동안 누군가의 리뷰를 기다리며 방치되는 것에 만족하는 것이 미친 짓처럼 느껴집니다. 분명 다른 방법이 있어야 합니다. 물론 한 가지 방법은 당신이 말씀하신 페어 프로그래밍입니다. 코드가 지속적으로 리뷰되고, 그런 경우에는 외부 리뷰가 필요 없을 수도 있습니다. 원할 수는 있겠지만, 그것만으로도 만족할 수 있죠.

켄트 벡: 네, 그리고 제 또 다른 미친 아이디어는, 코드 리뷰가 비동기식이지만 블로킹되지 않는다면 어떨까 하는 겁니다. 예를 들어 뉴스피드 같은 것이 있는데, 지금 코드베이스에서 일어나는 모든 변경 사항을 알려주는 거죠. 예전에 친구들이 뭘 하는지 보려고 페이스북을 켰던 것처럼, 이 도구를 열어서 "오, 코드베이스의 저 멀리 떨어진 부분에서 큰 리팩토링이 진행 중인 것 같네. 그런데 네가 지난주에 세 번이나 변경했던 이 파일은 다른 사람이 방금 변경했어"라고 알려주는 겁니다. 그건 뉴스죠. 제가 신경 쓰는 뉴스인 티커(ticker) 같은 겁니다. 저는 그런 티커 기능을 만들 수 있다고 생각합니다. 그러면 이 모든 블로킹, 큐잉 시간, 대기 시간, 그리고 그로 인해 발생하는 추가적인 변동성의 비용을 치르지 않고도, 시스템 전체에서 일어나는 변경 사항에 대한 고밀도, 고관련성 정보를 얻을 수 있을 겁니다. 스택드 디프는 비합리적인 시스템에 대한 합리적인 대응입니다. 그것이 스택드 디프에 대한 제 견해입니다.

루카: 네, 저도 거의 동의합니다. 'Ship, Show, Ask'라는 프레임워크도 있는데, 아시는지 모르겠습니다. 코드에 적용할 수 있는 변경 사항의 유형을 이 세 가지 범주로 나눕니다. 복잡성과 중요도에 따라요. 'Ship' 변경 사항은 아주 작은 변경으로, 리뷰나 다른 절차 없이 바로 배포할 수 있습니다. 스펙트럼의 반대편에는 'Ask'가 있는데, 멈춰서 리뷰를 기다려야 합니다. 그리고 중간 지점인 'Show'가 있습니다. 일단 배포하고 나중에 리뷰를 요청하는 비차단(non-blocking) 방식이죠. 핵심 아이디어는, 만약 작은 단위로 작업한다면 대부분의 작업이 'Show' 범주에 속할 수 있다는 것입니다. 리뷰를 받기는 하지만 전체 워크플로우를 막을 필요는 없는 거죠. 정확한 분류는 상황에 따라 달라질 수 있지만, 한쪽이나 다른 쪽으로 극단적인 접근 방식보다는 합리적으로 느껴집니다.

켄트 벡: 네, 제 접근 방식이 실제로 극단적이라고는 생각하지 않지만, 무슨 말씀이신지는 알겠습니다. 그리고 이것이 우리가 이야기했던 책임감의 일부입니다. 이것이 'Ask'가 아닌 'Show'라고 말함으로써, 당신은 "나는 이 디프(diff)의 결과에 대해 전적인 책임을 진다"고 말하는 겁니다. 만약 이것이 무언가를 망가뜨린다면, 우리는 그것을 즉시 알아내고 싶어 합니다. 제가 소프트웨어 설계에 관한 첫 번째 책인 'Tidy First'를 쓰면서 배운 것 중 하나는 행동 변경과 구조 변경의 차이입니다. 대부분의 구조 변경은 완전히 되돌릴 수 있습니다. 제가 헬퍼 함수를 추출했는데 당신이 "아, 저건 필요 없어"라고 말하고 그 함수를 인라인하면, 누가 신경 쓰겠어요? 하지만 제가 계산의 예상 결과를 바꾸면, 그것은 되돌릴 수 없는 경향이 있습니다. 만약 제가 세무 당국에 잘못된 숫자를 보내면, 그 변경을 되돌리는 것은 변경을 하는 것보다 훨씬 더 비용이 많이 들 겁니다.

그래서 시스템의 행동 변경에 대해서는 구조 변경보다 훨씬 더 신중해야 합니다. 왜냐하면 구조 변경은 대부분 되돌릴 수 있는 결정이기 때문입니다. 그것들은 'Ship'이나 'Show' 범주에 속하죠. 그냥 하세요. 프로그래머로서, 제가 어떤 작업을 하면서 시스템의 구조를 바꾸고 싶고, 소프트웨어 설계를 하고 싶지만, 동시에 새로운 테스트 케이스를 추가하고 통과시키고 싶다면, 이 두 종류의 작업을 분리해야 합니다. 아마도 먼저 모든 구조 변경을 하고 그 다음에 행동 변경을 하거나, 그 반대이거나, 아니면 어떤 새로운 방식으로 섞여 있을 수도 있습니다. 이것은 제가 엔지니어로서 해야 할 새로운 작업입니다. 그냥 "여기 큰 디프가 있는데, 리팩토링도 있고, 새로운 테스트 케이스도 있고, 제가 어서션(assertion)을 바꾼 기존 테스트 케이스도 있어요"라고 모든 것을 한데 뭉쳐놓는 대신에요. 읽는 사람으로서 제가 어떻게 "좋아요, 이건 괜찮습니다"라고 피로 서명할 수 있겠어요? 불가능하죠. 그냥 "lgtm"(looks good to me)이라고 하고 넘어가겠죠.

루카: 네, 우리는 신뢰, 주인의식, 그리고 좋은 관계로 다시 돌아왔네요. 다른 주제로 넘어가고 싶습니다. 렌켄트(renkent)나 챗GPT와 관련된 다른 것들을 언급하셨는데요. AI 주제를 조금 다뤄보고 싶습니다. 오늘날 당신의 가장 유명한 트윗은 당신의 기술에 대해 인용한 것입니다. 당신은 "내 기술의 90%는 이제 쓸모없게 되었다"고 말했습니다. 코파일럿이나 챗GPT를 처음으로 코딩에 사용해 본 맥락에서였죠. 당신은 당신 기술의 90%가 이제 쓸모없어졌지만, 남은 10%의 레버리지는 100배, 아니 1000배가 올랐다고 했습니다. 제가 당신을 인용하려면 제대로 해야죠. 당신은 적응해야 하고, 갑자기 저렴해진 것과 대비하여 가치 있는 것이 무엇인지 발견해야 한다고 말했습니다. 제 질문은, 그것을 찾으셨나요? 적응하셨나요?

켄트 벡: 적응 중입니다. 새로운 모델과 모델의 개선, 그리고 사람들이 "와, 지난주에는 37점이었는데, 새로운 라이브러리가 나오니 이제 55점이야. 아무것도 바꾸지 않았는데도 말이지"라고 말하는 세상, 그건 이제 흔한 일입니다. 이것은 파도가 온갖 방식으로 부서지는 서핑 상황 중 하나이며, 당신이 할 수 있는 최선은 그저 서핑을 할 수 있기를 바라는 것뿐입니다. 그래서 저는 적응 중이라고 말하고 싶습니다.

이번 주에 한 실험은... 수요일이죠, 네. 이번 주에 한 실험은, 제가 이 새 책 'Tidy First'를 냈는데, 어디엔가 복사본이 있을 겁니다. 이 책은 괴짜(geek)들을 위한 것입니다. 하지만 괴짜들이 이 책을 읽고 그들의 관리자가 하지 말라고 한다면 아무런 영향도 미치지 못할 겁니다. 그래서 저는 생각했습니다. "임원용 요약 보고서를 쓸 수 있을까? 이 작은 책을, 물론 가치는 무게가 아니라 내용에 있지만, 이 세 시간짜리 독서를 임원의 시간을 90% 절약해 줄 수 있을까? 일상적인 기술적 배경이 없는 사람이 읽고 전체적인 내용을 파악할 수 있는 보고서를 쓸 수 있을까?" 네, 그러면 좋겠죠. 'Tidy First'를 읽고 이 내용을 실행하고 싶은데 반대에 부딪히는 엔지니어들에게도 좋고, 임원들에게도 좋고, 그들의 고객들에게도 좋을 겁니다. 네, 그러면 좋겠죠. 일이 많을 텐데요.

"하루 시간이 있네. 챗GPT한테 이걸 쓰게 할 수 있을까? 그냥 일반 챗GPT가 아니라, 내가 작업 중인 이 렌켄트(renkent) 프로젝트처럼, 렌켄트한테 이 임원용 요약 보고서 전체를 쓰게 할 수 있을까?" 그리고 언어 모델에게 다음 장이 무엇을 말해야 하는지에 대한 지침을 알아내는 것은 정말 흥미로웠습니다. 저는 "이 장의 목표는 이것을 이해하는 사람을 데려와서 이 새로운 것을 이해하도록 돕는 것이다. 그리고 이 장이 끝날 때쯤이면 그들은 이 새로운 것을 이해하게 될 것이다. 비유를 사용하거나, 이 특정 비유를 사용하고, 이 세 가지 요점을 확실히 짚어라. 그리고 마지막에는 이 주제에 대한 다음 장으로 넘어가는 연결 고리가 있을 것이다. 그러니 이 장의 주제에서 다음 장의 주제로 전환하라."와 같이 매우 명확해야 했습니다.

이것이 바로 글쓰기입니다. 저는 글자 단위나 단어 단위, 문장 단위가 아니라 목표 단위로 글을 쓰고 있습니다. 이것은 제가 글을 쓸 때 항상 제 머릿속에서 일어나는 사고 과정의 일종입니다. 저는 500만 단어를 썼고, 그 사고 과정은 제 머릿속에서 꽤 정제되어 있습니다. 아이디어들을 어떻게 연결하고 싶은지 알죠. 하지만 이렇게까지 명시적으로 표현해야 했던 적은 없었습니다. 그래서 하루가 끝날 무렵, 저는 5,500 단어를 얻었습니다. 보통 제가 쓰는 단어 수의 3배 정도죠. 하지만 그것들은 챗GPT의 단어들입니다. 비록 제 글과 스타일 등으로 훈련된 렌켄트의 단어들이지만요. 작가로서의 제 관점에서 볼 때 언어 모델이 저지르는 멍청한 실수들이 있었습니다.

그래서 이틀 동안 모든 것을 편집했고, 이제 임원용 요약 보고서가 완성되었습니다. 제 목소리로 쓰여졌죠. 그리고 그 안에는 제가 "와, 이건 정말 좋은 비유인데. 전에는 생각 못 했어"라고 생각하게 만든 몇몇 놀라운 순간들도 있었습니다. 어떤 면에서는 제가 썼을 것보다 최종 결과물이 더 낫습니다. 그리고 제가 직접 앉아서 1장부터 한 단어 한 단어 타이핑하기를 기다렸을 때보다 확실히 훨씬 더 빨리, 그리고 훨씬 더 적은 편차로 완성되었습니다. 네, 챗GPT 버전은 그냥 나빴습니다. 하지만 화가 날 만큼은 충분히 좋았습니다. 네, 하지만 그것이 제가 들어가서 "아니, 아니, 아니, 그게 요점이 아니잖아. 이걸 저걸로 바꿔"라고 할 수 있는 감정적 에너지를 주었습니다.

그래서 제 글쓰기 기술, 즉 문장 안에 단어를 배열하는 능력은 제가 매우 열심히 노력해왔지만, 그다지 활용되지 않았습니다. 하지만 "여기 여덟 개의 챕터가 있고, 이런 순서로 진행되며, 이렇게 서로 연결된다"고 말하는 제 능력은 훨씬 더 높은 레버리지를 갖게 되었습니다. 만약 주제만 있다면 매주 이런 것을 하나씩 만들어낼 수 있을 겁니다. 하지만 이것은 제가 이 경험을 하기 전까지는 제가 가지고 있다는 사실조차 깨닫지 못했던 기술입니다. 이것이 바로 이제 엄청난 레버리지를 갖게 된 기술의 10%에 대한 예시입니다.

루카: 네, 이건 저에게 정말 흥미롭습니다. 왜냐하면 저는 이것이 결국 우리 팀으로서, 예를 들어 이 모델들을 사용하고 프롬프트와 프롬프트 엔지니어링을 통해 일을 하는 워크플로우를 어떻게 바꿀지 계속 궁금해하기 때문입니다. 당신은 임원 요약 보고서를 만드는 예를 드셨는데, 그건 무엇이든 될 수 있습니다. 코드를 만드는 것일 수도 있죠. 제가 항상 궁금해하는 것은, 과연 이런 상호작용 방식이 우리가 발명한 가장 선언적인 언어처럼 작용할 것인가 하는 점입니다. 그냥 원하는 것을 선언하면 그것을 얻게 되는 거죠. 그리고 그 다음에는 어디로 가야 할지 모르겠습니다. 우리가 프롬프트를 버전 관리하게 될까요? 아니면 무엇이...

그건 정말 거칠죠. 왜냐하면 어떤 수준에서는 수십 년 동안 서로의 위에 더 간단하고 더 간단한 새로운 언어를 계속 발명해 온 사람들이 있기 때문입니다. 그래서 지금은 단지 그런 시대 중 하나일 뿐입니다. 동시에, 모델이 코드를 생성할 때 우리는 여전히 모델이 생성한 코드 위에서 작업하고 있기 때문에 정확히 그런 느낌은 아닙니다. 그래서 이에 대한 답은 없습니다.

켄트 벡: 저도 마찬가지입니다. 정말 흥미롭다고 생각합니다. 저는 우리가 새로운 형태의 문학의 문턱에 서 있다고 생각합니다. 제가 프롬프트로 입력했던 것들, 그게 바로 글쓰기입니다. 이제 글쓰기는 이전과는 다른 모습을 갖게 되었습니다. 하지만 그것은 또한 프로그래밍과도 매우 비슷합니다. 도대체 무슨 일이 일어나고 있는지 알 수 없죠. 무언가를 생성하면 "아니, 이건 아니야"라고 생각하게 됩니다. 저 안에서 무슨 일이 일어나고 있는 걸까요? 이 기계에 대한 지침을 어떻게 바꿀 수 있을까요? 그런데 그 기계는 불가해하고 비결정적입니다. 마치 프로그램이 실행되는 동안 예측할 수 없는 방식으로 명령어의 정의가 바뀌는 칩을 프로그래밍하는 것과 같습니다. 하지만 여전히 프로그래밍이죠. 그래서 그 중간 어딘가에 있습니다.

그리고 제 큰 비전은... 저는 주변에 많은 기억 보조 도구를 가지고 있습니다. 인덱스 카드, 페이스 또는 애플 노트, 그림을 그리고 작은 노트를 공책에 적는 등 여러 가지를 사용하죠. 저는 이 모호한 미래적 감각 속에서, 그 모든 생각들이 하나의 모델로 들어가는 것을 볼 수 있습니다. 그리고 그 모델은 다양한 방식으로 렌더링됩니다. 그래서 "좋아, 여기 책이 있어. 모델에서 이런 것들을 꺼내서 책으로 만들자. 이제 네가 가질 수 있어"라고 말할 수 있습니다. 이것은 오늘날 음악가들에게 바이닐(LP)이 된 것과 비슷할 겁니다. 이걸 스트리밍하고, 저걸 스트리밍하고, 어쿠스틱 버전을 시도하고, 누군가와 협업한 다음, "음, 저 12가지가 잘 어울리네. 저걸 바이닐로 찍어서 팔자"라고 하는 거죠. 책도 그렇게 될 겁니다. 지적인 삶을 사는 지식인으로서, 저는 제 아이디어들을 가져와 이 모델에 쏟아부을 겁니다. 그리고 가끔씩 "좋아, 여기 릴리스가 있어. 여기 결과물이 있어"라고 말하고, 그것을 아름다운 종이에 인쇄해서 사람들에게 보낼 겁니다. 그러면 그건 유용하고, 읽을 수 있고, 어떤 향수를 불러일으키겠죠. 하지만 진짜 중요한 것은 제가 정기적으로 작업하는 이 모델입니다. 네, 그래서 저는 장기적으로 이것이 그렇게 될 것이라고 봅니다.

루카: 네, 저도 당신의 의견에 거의 동의하고, 채팅창에서 Clemens가 한 말도 마음에 듭니다. 기본적으로 이 모델들은 당신의 취향과 분별력을 활용하게 해준다는 거죠. 그래서 만약 사람들의 취향과 기술 사이에 격차가 있었다면, 오늘날 그 격차는 훨씬 작아졌다고 생각합니다. 좋은 결과에 대한 좋은 취향이 있다면, 이전보다 훨씬 더 많은 것을 할 수 있으니까요.

켄트 벡: 취향은 이제 그 레버리지가 1000배가 된 기술 중 하나입니다. 그리고 취향은 기술의 서투른 연습에서 나옵니다. 바로 그거죠. 그게 바로 트윗감입니다. 취향과 판단력을 얻는 방법은 일을 하고, 실수를 보고, 교훈을 얻고, 통찰력을 얻는 것입니다. "아, 만약 내가 이것을 저 순서 대신 이 순서로 했더라면, 일이 훨씬 더 잘 풀렸을 텐데." 그렇게 취향을 얻는 겁니다. 그래서 기술 연습을 건너뛸 수는 없지만, 그 기술들은 이제 우리가 예상하지 못했던 방식으로 가속화되었습니다. 특히 이 속도로는요.

루카: 네, 채팅창에서 Clemens의 질문을 가져왔습니다. "LLM 애플리케이션을 어떻게 TDD(테스트 주도 개발)할까요? 어떻게 테스트를 설계할까요?" 이 질문을 조금 더 넓게 본다면, "우리는 AI에게 테스트를 작성하게 할 것인가, 아니면 AI가 작성한 코드에 대한 테스트를 우리가 작성할 것인가?" 또는 "이것이 프로그래머로서 우리에게 어떤 영향을 미칠 것인가?"라는 더 넓은 질문이 있다고 생각합니다. 하지만 너무 벗어나고 싶지는 않네요.

켄트 벡: 좋아요, 그 질문에 답하고 싶습니다. 시간이 있다면 다시 물어보세요. 제가 들은 질문은 두 가지였습니다. 하나는 "개인화된 모델을 만들고 싶은데, 모델을 미세 조정하는 데 TDD 스타일의 워크플로우를 어떻게 적용할 수 있는가?"였고, 또 다른 하나는 아마도 더 일반적으로 "이미 엔지니어링 작업에 TDD를 하고 있다면, AI의 지원을 받아 엔지니어링 작업을 하는 것과 TDD를 어떻게 결합할 수 있는가?"였습니다. 후자가 더 일반적인 질문이었던 것 같습니다.

만약 그게 질문이라면, 제 직장인 Mechanical Orchard에서 흥미로운 실험을 했습니다. 챗봇 두 개를 두고, 하나에게 "이것에 대한 테스트를 작성해 줘"라고 요청하면 테스트를 작성해 줍니다. 그걸 복사해서 다른 챗봇에 붙여넣고 "이 테스트를 통과하는 코드를 작성해 줘"라고 하면 코드가 나옵니다. 이런 식으로 두 봇이 서로 대화하게 하는 거죠.

문제는, 당신이 명시해야 하는 정보 이론상의 최소 비트 수가 있다는 겁니다. "수익성 있는 앱을 만들어 줘"라고 말할 수는 없죠. 물론 그랬으면 좋겠지만요. 만약 당신이 할 수 있다면 다른 모든 사람도 할 수 있을 것이고, 모두가 그렇게 한다면 아무도 할 수 없게 될 겁니다. 그래서 실제로 입력해야 하는 최소한의 정보량이 있습니다. 제가 가끔 테스트로 하는 연습이 있습니다. 사람들이 제게 테스트를 보여주는데, 종종 정말 깁니다. 그럼 저는 "이 테스트의 이야기를 해보세요"라고 말합니다. "만약 이자율이 이렇고, 그 사람이 이렇고, 저렇고..." 그럼 저는 형광펜을 들고 그들이 제게 설명한 실제 정보만 테스트에서 강조 표시합니다. 어떤 테스트 스타일에서는 이렇게 긴 테스트에 실제 정보는 네 조각 정도밖에 없고, 수천, 수만 개의 토큰은 실제로는 아무 정보도 전달하지 않습니다.

바로 그 네 비트의 매우 구체적인 정보, 그것이 바로 우리가 초기 프롬프트에서 표현할 수 있어야 하는 것입니다. 그렇지 않으면 그냥 무작위적인 것들이 나올 뿐입니다. 하지만 언어 모델은 당신이 말하는 것에 대해 많은 맥락을 가질 수 있습니다. 마치 당신과 제가 같은 시스템에서 1년 동안 함께 일하면 제가 그냥 "아, 그거 있잖아"라고만 해도 당신이 "네, 무슨 말씀인지 정확히 알아요"라고 하는 것과 같습니다. 모델도 시간이 지남에 따라, 특히 당신의 특정 코드베이스, 작업 스타일, 어휘 등에 맞게 미세 조정된다면 그런 풍부한 맥락을 가질 수 있습니다. 그래서 우리는 언어 모델에게 점점 더 응축된 정보를 말하고 신뢰할 수 있는 코드를 얻을 수 있게 될 겁니다.

루카: 네, 동의합니다. 정말 흥미롭네요. 몇 시간이고 더 질문을 계속할 수 있겠지만, 이제 마무리해야 할 시간입니다. 오늘 이 멋진 대화를 위해 함께해주셔서 정말, 정말 감사합니다.

켄트 벡: 오, 루카, 정말 제 기쁨입니다. 곧 직접 뵐 수 있기를 바랍니다.

루카: 물론입니다. 그리고 보니 엔지니어링뿐만 아니라 기타 실력에서도 저를 압도하시는군요. 배경에 저는 두 대 있는데, 당신은 여섯 대인가 일곱 대가 있네요. 그 점에서는 당신이 이겼습니다.

켄트 벡: 그것보다 조금 더 많습니다.

루카: 네, 다시 한번 감사합니다, 켄트.

켄트 벡: 물론이죠. 곧 뵙겠습니다. 안녕히 계세요.

루카: 들어주셔서 정말 감사합니다. 이 대화가 가치 있었다면, 유튜브, 애플 팟캐스트, 스포티파이 또는 즐겨 사용하는 팟캐스트 앱에서 쇼를 구독하실 수 있습니다. 또한, 평점이나 리뷰를 남겨주시면 다른 청취자들이 쇼를 찾는 데 정말 큰 도움이 됩니다. 모든 지난 에피소드는 refactoring.fm에서 찾아보실 수 있으며, 쇼에 대한 더 많은 정보도 얻으실 수 있습니다. 다음 에피소드에서 뵙겠습니다.
